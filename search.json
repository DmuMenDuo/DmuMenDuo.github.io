[{"title":"项目中java创建子进程造成的I/O阻塞问题定位和解决","url":"%2F2019%2F04%2F27%2Fjava-runtime-execute-inputstream-blocking%2F","content":"\n记录一个bug的debug过程，bug起因是`后台调度程序`启动一个异步任务去调用一个docker容器包裹的工具服务（mutation变异测试工具），正常运行的情况下docker容器会正常的退出并自我销毁。而这次的现象是docker容器没有退出而一直处于运行状态。\n\n<!-- more -->\n\n## 原因分析\n\n### docker下手\n分析`docker`未停止的原因大概率是docker所做的事情没有结束。所以，`docker exec`进入容器，用`jps`查看`Java进程`状态，果然发现进程并没有运行结束。\n\n### 观察java进程\n\n1. `jps`观察现象，有两个java进程在运行，`pid=430`就是我们的主进程，`pid=300`是主进程内新启动的一个子进程。\n```bash\n300 MutationTestMinion\n430 Jps\n```\n2. `jstask [pid]` 查看两个进程的线程栈。 \n**查看主进程的线程栈日志如下:**\n![主进程](http://pic.menduo.xyz/20190501204936.png)\n**查看子进程的线程栈日志如下:**\n![子进程](http://pic.menduo.xyz/20190501212950.png)\n**现象：**\n主线程正在读取inputStream,子线程正在写入outputStream。两个进程均阻塞住，无法继续运行。\n\n### 分析代码\n\n1. 拉代码，本地定位到具体的关键代码如下（比查bug更痛苦的就是查别的的bug了）\n```java\nString[] commands = {\"bash\", \"-c\", commandStr};\nProcess p = Runtime.getRuntime().exec(commands);\noutput = IOUtils.toString(p.getInputStream());\n``` \n\n2. 查看`Process`的文档和各种博客：\n\n**收集的有用的信息：**\n- 创建`Process`方式有两种： ① `ProcessBuilder`; ② `Runtime`.\n- 创建的`Process`没有自己的终端和控制台，他们的`标准I/O（stdin,stdout,stderr）`会被重定向给父进程，为此Process提供了方法`getOutputStream()`,`getInputStream()`,`getErrorStream()`来实现这个功能。\n- **重点：** 由于各平台对于标准I/O 设置了有限制的缓冲区大小。导致写入缓冲区可能会发生阻塞或者死锁的现象！！！原文：\n``` java\n /*\n * The parent process uses these streams to feed input to and get output\n * from the subprocess.  Because some native platforms only provide\n * limited buffer size for standard input and output streams, failure\n * to promptly write the input stream or read the output stream of\n * the subprocess may cause the subprocess to block, or even deadlock.\n */\n```\n\n## Bug详细解释\n\n通过上面的逐步分析，已经可以明显的知道原因是什么了：\n\n`子进程`在执行的过程中会向标准I/O的缓冲区中写入`标准输出`和`错误输出`，而主进程没有对子进程的`错误输出`进行处理，导致子进程发现`错误输出`缓冲区满了的时候自己阻塞住，无法继续运行。而主进程因为子进程无法运行结束，所以`getInputStream()`一直认为还会有数据，会一直等待来自子进程的`标准输出`，所以也阻塞在了`getInputStream()`。 程序中没有任何的超时机制，java进程阻塞住，所以docker也就阻塞住了。\n\n## 解决&引入新的bug \n\n关键点就是 要及时处理子进程的`标准输出`和`错误输出`,因此我们可以启动两个线程分别去处理两个输出，然后主进程等待子进程运行结束就可以了，关键代码如下：\n```java\nExecutorService single = Executors.newCachedThreadPool(); //启动个线程池\nFuture<String> errorOutput = single.submit(() -> IOUtils.toString(p.getErrorStream()));\nFuture<String> inputOutput = single.submit(() -> IOUtils.toString(p.getInputStream()));\nsingle.shutdown(); // 这里一定要主动关闭线程池。\np.waitFor(); //主线程挂起，等子进程结束\noutput = inputOutput.get(); // 获取输出结果\n```\n程序首先启动了一个线程池，添加了两个任务分别去处理标出输出和错误输出。然后关闭线程池，拒绝新的任务加入进来，主进程等待子进程运行结束后，再去获取线程池中的线程中的运行输出结果。\n\n我在写这个代码的时候引入了一个新的bug,就是没有手动关闭线程池,导致我有一段时间怀疑我之前看的文档和bug分析是不是错的，所以又去复现了一波，发现处理任务的子进程已经运行结束了，主进程park在了`ThreadPoolExecutor.getTask()`, 线程池在确认没有任务加入的时候一定要手动关闭`shutdown()`,否则会导致主进程因为有后台线程在运行的缘故，无法运行结束，造成的结果也是docker阻塞住，其实就是线程池在等待处理新的task而进行的自旋阻塞。幸好因为面试看过线程池源码，确认是线程池阻塞在等待任务的问题。所以多看源码还是对自己很有帮助的，有机会再总结一波线程池相关的源码分析。\n![线程池阻塞](http://pic.menduo.xyz/20190502153421.png)\n\n\n## 后记\n\n1. 关于线程池状态的说明\n\n```java\n/*  -1 RUNNING:  Accept new tasks and process queued tasks 可以接受新的任务并处理\n*   0 SHUTDOWN: Don't accept new tasks, but process queued tasks 不再接受新的任务，但是会处理完队列里的所有任务\n*   1 STOP:     Don't accept new tasks, don't process queued tasks, \n*             and interrupt in-progress tasks 不在接受任务，也不处理队列里的任务，同时中断正在处理任务\n*   2 TIDYING:  All tasks have terminated, workerCount is zero,\n*             the thread transitioning to state TIDYING\n*             will run the terminated() hook method 所有任务终止，worker数为0 线程改变状态为TIDYING \n*   3 TERMINATED: terminated() has completed 终止方法运行完成\n*/\n```\n\n\n2. 为什么这里线程池需要手动shutdown，直接看源码发现，线程池会不断的去获取`task`放入`worker`执行的代码是一个for死循环，其中的退出条件:\n   - 线程池状态码 >= SHUTDOWN 并且 （状态 >= STOP || 队列里没任务) 这个看上面的状态码就可以理解了，我们手动调用shutdown的原因就是这个\n   -  从队列里获取一个task,获取成功则返回\n\n```java\nprivate Runnable getTask() {\n        //...略\n        for (;;) {\n            int c = ctl.get(); \n            int rs = runStateOf(c); //获取线程池状态\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            //...略\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n## 参考资料\n\n1. Java doc\n2. [Process.getInputStream()阻塞问题](https://blog.csdn.net/yuanzihui/article/details/51093375)\n","tags":["开发"],"categories":["Java"]},{"title":"一道笔试题的思考:基本类型和包装类型进行数据比较的问题总结","url":"%2F2019%2F04%2F21%2Fint-with-integer%2F","content":"\n昨天阅文的一道笔试题，让仔细解释一下 `int`和`Integer`各种不同数据比较的问题，我发现自己能说出来的东西挺少的。阿里一面面试官说我了解知识的深度不够的问题，确实让我想了很多，其实我给自己的`特质`定位应该是可以迅速发现问题并解决、可以很快的举一反三，但是很少会因为这个问题去思考到底是底层是因为什么，也就是说`总结反思`的能力太差了，说白了还是修炼不到位，平时太懒了。\n\n所以以后遇到的每个问题都要认真的记录下来。争取秋招拿offer!\n\n<!-- more -->\n\n对于这个问题，首先有个**装箱**和**拆箱**的概念要首先被明确。也就是基本类型和包装类型可以相互转化。\n\n### 什么是装箱和拆箱？\n\n对于每一个基本类型都会有一个对应的包装类型。例如`int`的包装类型就是`Integer`。而拆箱动作就是将包装类型转化为基本类型，装箱动作就是将基本类型变成包装类型。\n\n#### 对应的API,以Integer为例：\n- 基本类型 --> 包装类型 Integer i = Integer.valueOf(int);\n\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)]; \n        //常量池缓存。[-128,127 or high] 默认127\n        //其中缓存池high大小可通过参数『java.lang.Integer.IntegerCache.high』进行调整,\n        //最大为Integer.MAX_VALUE - 128 - 1 \n    return new Integer(i);\n}\n```\n\n- 包装类型 --> 基本类型 int ii = i.intValue();\n\n``` java\npublic int intValue() {\n    return value;\n}\n```\n**总结：装箱操作就是调用包装类型的valueOf ;拆箱操作就是调用包装类型的xxValue()**\n\n#### Java可以做到自动拆箱和装箱\n\n> 在java中已经实现了自动拆箱和装箱的操作。\n\n> 时机：当任何一个操作中混用了基本类型和装箱类型，装箱类型就会进行拆箱操作。\n\n\n### 总结几个混合使用的要点\n\n#### 一些简单的测试用例进行解释整个 int和Integer进行比较的总结：\n\n- int 和 Integer进行混合比较时，Integer会进行拆箱操作变成基本类型。\n- Integer xx  = 1 这种会调用valueOf自动装箱。\n- Integer进行new操作的对象是放到堆上的。\n- Integer 调用valueOf返回的对象，分两种情况：① -128 <= x <= 127 返回的常量池缓冲区的对象 ② x > 128 会在堆上new一个新的对象 (只考虑默认的情况)\n\n#### 具体的几个测试用例\n```java\n    public static void main(String[] args) {\n        int a0 = 1;\n        int b0 = 128;\n        Integer a1 = 1;\n        Integer b1 = 128;\n        Integer a2 = new Integer(1);\n        Integer a3 = Integer.valueOf(1);\n        Integer b3 = Integer.valueOf(128);\n        Integer a4 = Integer.valueOf(1);\n        Integer b4 = Integer.valueOf(128);\n        System.out.println(a0 == a1); //true 首先a1返回的是常量池中的对象，又因为和int进行比较所以进行拆箱操作\n        System.out.println(b0 == b1); //true 同上，但是会在堆上new一个新的对象然后自动拆箱\n        System.out.println(a1 == a2); //false 首先 a1是缓存在常量池的对象，a2是在堆上new的对象\n        System.out.println(a3 == a2); //false a3返回的是放在常量池中的对象，两个对象不是同一个\n        System.out.println(a3 == a1); //true 返回都是常量池的中的对象，比较地址相等\n        System.out.println(a3 == a4); //true 返回都是常量池进行缓存过的对象，比较地址相等\n        System.out.println(b3 == b4); //false 两个堆上新new对象，具体看valueOf源码，在上面\n        System.out.println(a0 == a4); //true 拆箱比较\n        System.out.println(b0 == b4); //true 拆箱\n        System.out.println(b1 == b4); //false 装箱返回new的堆上对象 和 new的堆上对象\n    }\n```","tags":["基础知识"],"categories":["Java"]},{"title":"FileZip导致的JVM崩溃问题分析","url":"%2F2019%2F03%2F10%2Ffilezip-cause-jvm-crush-md%2F","content":"\n3.10 爬起床查日志，改bug.T_T.\n<!-- more -->\n\n## ZipFile 导致JVM奔溃现象分析\n\n### 现象：\n1. 日志无任何异常产生，但是服务进程已经死掉。定位到日志最后一行线程调用了`OnlineJudgeControler`，因此怀疑是慕码社区的代码（也就是我的锅T_T）导致的崩溃\n2. 查看JVM崩溃日志`hs_err_pid**.log`，发现down机时，线程发出了SIGBUS信号，线程停在了ZipFile对代码包解压上。搜索了一下网上关于这方面的解释。\n\n### 原因\n具体原因就是：我的一个接口会去下载一个压缩包到一个特定的目录，然后在解开这个压缩包（这个文件被映射到了系统内存），但是如果此时另外一个线程也执行这个接口就会将这个压缩包重写（改写了硬盘文件）。导致第一个解压过程出现异常（因此此时会发现自己已经被另外一个线程改变了），从而导致了JVM直接崩溃。\n\n**这里解释一下mmap内存机制：**\n\n我们知道直接对磁盘上的内容会比从内存中读去慢很多，mmap内存文件映射其实就是将磁盘上的一个文件映射到内存中的作用。进程通过对内存的修改来达到对文件的修改，因此mmap系统调用常常用于进程间共享内存方式的系统调用。\n\n**官方给出的关于mmap导致JVM崩溃的解释：**\n\nDisabling mmap Usage (on Solaris or Linux) This release includes a new system property, sun.zip.disableMemoryMapping, which allows the user to disable the mmap usage in Sun's java.util.zip.Zipfile implementation (on Solaris and Linux platforms). Solaris or Linux applications that use java.util.zip.ZipFile may experience a SIGBUS VM crash if the application accidentally overwrites any zip or jar files that are still being used by the same Java runtime. Although this is a programming error of the offending application, this system property provides a solution to avoid the VM crash. With the property set to true (-Dsun.zip.disableMemoryMapping=true, or simply -Dsun.zip.disableMemoryMapping) the Sun JDK/JRE runtime disables the mmap usage and the VM crash that might otherwise occur by overwriting the jar or zip file can be avoided.\n\n\n### 解决方法\n\n1. 官方说明的那样对zip禁用mmap\n> 在启动参数中加入-Dsun.zip.disableMemoryMapping=true \n2. 对代码进行修改，防止多个进程访问同一个文件，可以考虑加锁，或者对该文件进行备份，每个线程访问不同的文件\n\n\n### 参考资料\n\n> 参考资料1 https://blog.csdn.net/zqixiao_09/article/details/51088478\n> 参考资料2 https://my.oschina.net/shipley/blog/979231","tags":["日志"],"categories":["JVM"]},{"title":"headfirst设计模式-工厂和抽象工厂笔记","url":"%2F2018%2F12%2F03%2Fhead-first-1-factory%2F","content":"\n> 设计模式-工厂和抽象工厂。\n> github: [https://github.com/DmuMenDuo/JAVADesignPattern](https://github.com/DmuMenDuo/JAVADesignPattern/tree/master/src/xyz/menduo/factory)\n\n<!-- more -->\n\n## 工厂模式\n\n等到运行时才会知道去实例化哪个，工厂模式也是对设计原则中的将变化与不变化分离的典型应用。\n\n### 简单工厂模式\n\n**什么时候用简单工厂模式？**\n\n发现出现大量的条件判断去创建不同`instance`的对象的时候就可以考虑用工厂将其进行封装了。判断的理由就是这段代码出现了变化，所以要进行封装进行提取。\n\n简单工厂模式UML图：\n![简单工厂模式uml图](http://pic.menduo.xyz/20181130192703.png)\n\n\n### 静态工厂模式\n\n**静态工厂模式：**\n\n> 静态工厂模式只不过是将简单工厂模式的工厂变成了静态类 \n\n**静态工厂的优点和缺点？**\n\n> 优点：工厂无需实例化\n> 缺点：工厂无法通过继承来改变方法的行为。\n\n### 工厂模式\n\n![工厂UML图](http://pic.menduo.xyz/20181202152129.png)\n\n父类提供一个抽象方法，子类负责实现，这个实现的内容就是一个工厂在产生对象的过程。\n![工厂](http://pic.menduo.xyz/20181113154209166559267.png)\n\n\n**工厂模式定义：**\n\n工厂模式是用来封装'对象创建'使用的模式，他通过声明一个抽象父类让子类决定应该去创建什么具体对象。\n![工厂模式-2018111815425544733044.png](http://pic.menduo.xyz/2018111815425544733044.png)\n\n\n**简单工厂和工厂模式的区别？**\n\n工厂模式是创建了一种框架（父类定义，子类实现new对象）。而简单工厂没有。所有工厂模式比简单工厂更加有弹性。\n\n**工厂模式有什么好处？**\n\n封装了变化。代码可以重复利用，方便维护。\n\n\n### 抽象工厂模式\n我理解的`抽象`这个词的含义是，这个工厂类没有具体指明是什么具体的工厂，而是一组工厂，用来实例化一组产品组，或者实例化一个产品的各个部分。\n\n![20181118154255459072470.png](http://pic.menduo.xyz/20181118154255459072470.png)\n\n\n### 对比一下工厂模式和抽象工厂模式\n\n1. 工厂模式采用的继承的方式，父类定义个抽象方法，子类去实现。这个实现的过程就是去创建自己需要的对象。\n2. 抽象工厂是定义一个公共接口，每一个接口都是一个要实例化对象的方法。抽象工厂在使用的时候会被当成属性注入需要实例化的地方。","tags":["设计模式"],"categories":["设计模式"]},{"title":"青海小憩","url":"%2F2018%2F08%2F10%2Fqinghai5day%2F","content":"\n距离开学还有一个月的时间，一次去参加会议的偶然机会，就有了这次的青海五日游。\n刚刚好的季节，刚刚好的行程。吃过了最好吃的羊肉，喝过了最好喝的酸奶，看过了最好看的天。人生也就不过如此吧！\n\n\n\n<!-- more -->\n\n\n\n##### 旅行前的准备\n\n其实要准备的东西也没有什么的，最重要的保命物品就是`防晒霜`!!!。不管男生女生这个真的很重要，我滴妈，我没带被晒得老惨了，褪了一层皮；带一件`外套`和`长裤`，那边早上和晚上还是挺冷的。emmmmm.可以带双`拖鞋`，天空之境还是蛮漂亮的，如果要去盐湖的话可以带双拖鞋准备下水用。还有就是`相机`,那边太漂亮啦，只恨自己拍照技术太渣，手机像素太渣。\n\n##### 第一天：西宁市: 青海省博物馆 -- 东关清真寺 -- 莫家街\n到了西宁一定要去试一下当地的手撕羊肉和老酸奶，实在而且超级好吃，反正我们是安顿好住宿就去找手撕羊肉了。之后去了一下青海省博物馆，它也在西宁市内而且没有门票费，如果想去了解当地文化的话可以去那里转转；因为那边穆斯林比较多，所以清真寺也会比较多，东关清真寺应该当地最大的一座清真寺了，里面还有人讲解穆斯林文化；最后就是晚上去莫家街找吃的，这条小吃街还是蛮有名的，好像正好赶上那边的美食节，所以吃的很满足。\n![西宁市内](http://pic.menduo.xyz/20181113154207578552083.jpg)\n\n##### 第二天：塔尔寺 -- 拉脊山 -- 青海湖二郎剑\n塔尔寺，藏传佛教的圣地。\n<!-- ![塔尔寺](http://pic.menduo.xyz/20181113154207665760536.jpg) -->\n![塔尔寺](http://pic.menduo.xyz/20181113154207693250517.jpg)\n逛过塔尔寺之后就准备去青海湖二郎剑啦，中间穿过了拉脊山，最高海拔4500多米，讲道理还是会有高原反应的，不过司机建议是不要吸氧气，适应适应就好啦。下面的照片就是在拉脊山上拍的。\n![拉脊山](http://pic.menduo.xyz/20181113154207816952435.jpg)\n青海湖二郎剑景区，图1是在船上拍到的，可以看见的阳光。图二叫经幡，当地牧民用来祈求福运隆昌，消灾灭殃。\n![青海湖二郎剑](http://pic.menduo.xyz/20181113154207873353621.jpg)\n之后住宿的地方可以选择黑水镇，不过我们没有订到，所以去了很远的石乃亥，以至于去天空之境的时候多走了一段重复的路。不过路上风景很美所以不会很无聊。\n##### 第三天：石乃亥 -- 天空之境\n本来是有安排看日出的，不过很遗憾的是在石乃亥的两天早上都是阴天还下了小雨，到九点多才晴天。不过还好到天空之境，也就是卡茶盐湖的时候，天气很给面子。\n![天空之境-卡茶盐湖](http://pic.menduo.xyz/20181114154212694423885.jpg)\n其实我们的行程蛮充裕的。以至于在青海湖旁边的草原上玩了一下午。和小伙伴们跳到缺氧。。。。\n![青海湖旁不知名草场](http://pic.menduo.xyz/20181114154212697758897.jpg)\n##### 第四天：回到西宁市\n第四天就是回到西宁市准备开会啦。中间去了原子城学习了一下，抱着学习的目的所以就没拍照片了，然后就是季节有点晚要不然可以看到成片的油菜花海。我们去的时候已经没有了。\n\n\n-- end -- \n\n\n","tags":["青海"],"categories":["旅行"]},{"title":"使用Docker-Java动态的获取Container的log日志","url":"%2F2017%2F12%2F13%2Fget-log-from-docker-container%2F","content":"\ndocker-java 是 JAVA 操作Docker Remote API 的一个工具。最近项目需要读取容器的运行日志出来。记录一下自己遇到的问题。更多其他的问题可以参考他们的测试用例。\n> github地址: [docker-java](https://github.com/docker-java/docker-java) 目前版本 3.0.13\n\n<!-- more -->\n\n### 准备工作\n#### 1. 首先要开启docker的客户端 (我电脑 ubuntu16.04)\n\n```bash\n#查看配置文件位于哪里\nsystemctl show --property=FragmentPath docker \n#编辑配置文件内容，接收所有ip请求\nsudo gedit /lib/systemd/system/docker.service  \nExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://127.0.0.1:8787\n# 这样配置的目的是可以通过http的方式进行远程访问，如果不需要的话可以通过自带的sock方式本地访问\n#重新加载配置文件，重启docker daemon\nsudo systemctl daemon-reload     \nsudo systemctl restart docker \n\n```\n\n#### 2. 建工程 && pom.xml引入依赖\n\n```xml\n<dependency>\n  <groupId>com.github.docker-java</groupId>\n  <artifactId>docker-java</artifactId>\n  <version>3.0.13</version>\n</dependency>\n```\n\n### 获取容器实时运行结果\n\n\n> 通过查看容器日志的方式,\n> 设置一个回调函数，重写onNext(),就可以取到运行的结果了\n\n```java\ndockerClient.logContainerCmd(dockerId).withStdOut(true).withStdErr(true)\n                    .exec(new LogContainerResultCallback(){\n                        @Override\n                        public void onNext(Frame item) {\n                            super.onNext(item);\n                            System.out.println(\"容器运行的结果：\"+item.toString())\n                        }\n                        @Override\n                        public void onComplete() {\n                            super.onComplete();\n                        }\n                    }).awaitCompletion();\n```\n\n> `awaitComletion()`就是让查日志进程阻塞，直到进程调用onComlete()\n> 最好等容器停止后再去读，因为容器在运行中可能还没产生日志，但callback读的时候以为读完了，直接执行onComplete就结束了，因此没有输出。 所以建议查日志前，检查一下容器运行情况，代码如下：之后一直循环判断直到容器停止就可以了\n\n```java\n\t//获取容器的运行状态\n\tdockerClient.inspectContainerCmd(dockerId).\n                exec().getState().getRunning();\n```\n\n\n","tags":["bug解决"],"categories":["docker"]},{"title":"翻译文章:JVM架构简析","url":"%2F2017%2F10%2F10%2Ftrans-jvm-structure%2F","content":"\n\n每个JAVA开发者都知道字节码将会被**JRE**（java运行时环境）所执行，但是许多人不知道的是**JRE**是**java虚拟机**（JVM）分析字节码，解释代码，以及执行它的那部分实现。对于一个开发者来说知道了解JVM的架构是非常重要的，因为它可以让我们更有效地编写代码。在这篇文章，我们将更深入的了解java中的**JVM架构**以及JVM的**不同组成部分**。\n\n> 原文地址：https://dzone.com/articles/jvm-architecture-explained\n\n<!--more-->\n\n----------\n\n## JVM架构简析\n\n\n> 一个JVM不同组成部分的综述，以及和其相关的一些图表\n\n![20181119154259959133032.png](http://pic.menduo.xyz/20181119154259959133032.png)\n\n### 什么是JVM？\n\n一个**虚拟机**是一个物理机的软件实现。java开发的概念是**WORA（一次编写到处运行）**，所以运行在**虚拟机**上。**编译器**编译java文件生成**.class**文件。然后**.class**文件被放入到一个可以加载执行他的虚拟机中。下面是一个JVM 架构的图。\n\n### JVM是如何工作的？\n\n在上述的架构图中，JVM被分成了三个主要的子系统：\n\n1. 类加载子系统。\n2. 运行时数据区域。\n3. 执行引擎。\n\n#### 1. 类加载子系统\n\njava的动态类加载机制在类加载子系统中被处理。由它加载，连接，以及在**运行时**第一次引用类时初始化类文件，而不是在**编译时**。\n\n##### 1.1. 加载\n\n类们将会被这个组件加载。BootStrap 类加载器 ，Extension 类加载器，和Application类加载器将会帮助完成这个过程。\n\n1.  **BootStrap类加载器** - 它的责任是加载那些启动相关路径里的类，不仅仅只是rt.jar。最高的优先权被给于给这个加载器。\n\n2.  **Extension类加载器** - 它的责任是加载那些包含在**jre/lib下的ext**文件夹内的类。\n\n3.  **Application类加载器** - 他的责任是加载**用户定义的classpath下**以及路径涉及的环境变量等等里面的类。\n\n上述的**类加载器**都遵循**双亲委派模型**去加载类文件。\n\n##### 1.2 连接\n\n1.  **验证 **- 字节码验证器将会验证生成的字节码是否正确，如果验证失败那么我们将得到一个验证错误。\n\n2.  **准备** - 为所有静态变量分配内存并且设置初始值。\n\n3.  **解析** - 所有的符号引用将会被替换成方法区的直接引用。 \n\n##### 1.3 初始化\n\n这是类加载的最后时期，这时候所有的静态变量都会被赋予初值，并且执行类中的静态块。\n\n\n#### 2. 运行时数据区\n\n运行时数据区被分成了五个主要部分：\n\n\n- **方法区** - 所有**类相关数据**将会被存储在这里，包括静态变量。每一个JVM只有一个方法区，所以它中的资源是被共享的。\n- **堆** - 所有的**对象**以及他们相关的**实例化变量和数组**被存储在这里。每一个JVM也只有一个堆。因为**方法区**和**堆**是线程间共享的，因此数据的存储**不是线程安全**的。\n- **栈** - 对于每个线程，都将创建一个单独的**运行时栈**。对于每一个**方法调用**，一个被叫做**栈桢**的实体将会在栈内存中被创建。所有的**局部变量**将会在栈空间被创建。栈空间是线程安全的因为它不共享资源。栈桢被分成如下三个子部分：\n    - **局部变量表** - 涉及方法的所有**本地变量**以及和他相关的值被储存在这里。\n    - **操作数栈** - 如果需要执行任何中间操作，**操作数栈**扮演者运行时工作空间的作用去执行这些操作。\n    - **桢数据** - 该方法对应的所有符号都存储在这里。在任何**异常**情况下，捕获块信息将在帧数据中维护。\n- **程序计数器** - 每一个线程都有一个独立的**程序计数器**，来保存**当前指令地址**，一旦指令执行完成就**更新**程序计数器为下一条指令地址。\n- **本地方法栈** - 本地方法栈保存本地方法信息。对于每一个线程，一个独立的本地方法栈将会被创建。\n\n#### 3. 执行引擎\n\n分配到**运行时数据区**的字节码会被执行引擎执行。执行引擎读取字节码并逐步的执行。\n\n-  **解释器** -  解释器可以很快的解释字节码，但是却执行的很慢。解释器的一个缺点就是当一个方法被调用多次后，每次都需要重新被解释。\n-  **实时编译器** - 实时编译器弥补了解释器的不足。执行引擎将在转换字节代码时使用解释器的帮助，但是当它发现重复的代码时，它使用的是JIT编译器，它编译整个字节码并将其更改为本地代码。这种本地方法将会直接被使用在重复的方法调用上，来提升系统的性能。\n    - **中间代码生成器** - 生成中间代码。\n    - **代码优化器** - 负责优化上面生成的中间代码。\n    - **目标代码生成器** - 负责生成机器代码或本地代码\n    - **分析器** - 一个特殊的组件，负责找热点，例如，是否一个方法被多次调用等等。\n\n- **垃圾收集器** - 收集以及移除未被引用的对象。垃圾回收将会被这个\"**System.gc()**\"调用触发,但是这个执行时不确定的。JVM的垃圾收集器收集被创建的对象。\n\n**Java Native Interface (JNI)**: **JNI**将与**本地方法库**交互，并提供执行引擎所需的本地库。\n**本地方法库**:它是执行引擎所需的本地库的集合。\n","tags":["JVM"],"categories":["java"]},{"title":"2018年专业书单","url":"%2F2017%2F09%2F12%2F2018booklist%2F","content":"\n软狗不是每天都在搬砖的！！！ 我爱学习~\n\n今年要补些本科落下的基础知识了。面试时候遇到的JAVA相关的知识。毕设要用到Docker和机器学习算法也学一下。 软狗要全栈（除了前端\n<!-- more -->\n\n####  JAVA并发编程艺术\n\n> java并发的一些基础知识，以及J.U.C的一些常用类。PS：新买的，在火车上看了1/3就丢了，现在只能啃电子书。很真实。。。mmp\n\n\n#### JAVA8函数式编程\n\n> 强烈推荐，如果想快速上手Java8,学会Lamda，这是一本好书，很薄，代码也可以在github下载到\n\n#### Docker技术入门与实战\n\n> 一本关于docker的工具书。\n\n\n####  Effecttive Java 英文版（第三版）\n\n> 第三版相对于第二版多了很多JAVA8的内容，由于还没有中文版，所以只能读英文的了\n\n#### 机器学习\n\n> 读论文的时候发现很多人在用机器学习的算法，周大牛的机器学习是必备的吧 \n\n\n\n\n","tags":["读书"],"categories":["读书"]},{"title":"2018年娱乐书单","url":"%2F2017%2F09%2F12%2F2018booklist2%2F","content":"\n经常被说文盲，多读书是好呀，和别人聊天可以找找话题~\n\n\n\n<!-- more -->\n\n1. 未来简史 `看不懂看不懂...`\n2. 白金数据 `算不算马上就成为现实的故事？或者已经是现实了？`\n3. 从0到1:开启商业与未来的秘密 `我觉得从投资人的角度对于一个好创业公司的讲解很透彻，应该如何看待创业公司，以及创业公司应该如何生存法则。`\n4. 这世界既残酷也温柔 `我觉得很无聊的一本书,没什么值得借鉴的营养故事,装逼史:北大-->留学-->买比特币-->财务自由-->持续创业。不过抓住机会的能力还是要学习的`\n5. 摆渡人 `超级治愈的一本书`\n6. 摆渡人2 `感觉没有上一部写的好，对于苏珊珊的结局，我不喜欢作者这样处理她，不剧透，23333`\n7. 一只特立独行的猪 `这是一本充斥着个人观点的书，对待任何的事情都要有自己的态度，要会为自己的观点坚持，这就是王小波吧。一个幽默，有个性的老人儿`\n8. 梦幻花 `关于一株不存在的致幻花的故事，真的很佩服东野圭吾，总可以在恰到好处的时候将所有的片段结成一个完整的故事。`\n9. 虚无的十字架 `我认为是一本十分矛盾的书，每个人都是在弥补自己曾经的过错去做另一件更错的事。书中的很多思想关于判刑对一个人以及其周围的影响，冲击着日本目前的法律制度。可能是因为之前的江歌案吧，日本的法律真的可以宽恕罪行。`\n10. 刺杀骑士团团长 `一开始以为书中的我产生了人格分裂，那个骑士团长以及斯巴鲁男人是他的两重人格，后来......书一直围绕着那幅可以救赎的刺杀骑士团长的画展开，不过结局矛盾的人全部得到了自己想要的答案真好啊。`\n11. 刺 `一本关于校园暴力，职场暴力以及网络暴力的书，文中想表达的思想全在字面上，很容易读懂。佩服作者敢于发声。`\n12. 高情商聊天术`记不得讲什么了，反正现在看感觉什么都没说`\n13. 毕业 `东野圭吾的小说总是很吸引人...其实不打算看的，但还是一口气看完了。可能脑子比较笨，经常猜不到结局才喜欢看的吧`\n14. 秘密 `又一本东野圭吾的书，在读到一半的时候猜到了我最不喜欢的结局！！！`4\n15. 龙族(1-4） `江南的小说还是很好看的！`\n16. 人月神话 `软件需求课的作业`","tags":["小说"],"categories":["读书"]},{"title":"2017娱乐书单","url":"%2F2017%2F01%2F05%2F2017booklist2%2F","content":"\n2017年小说书单\n\n<!-- more -->\n\n1. 不正常人类症候群 - 张寒寺\n2. 浮躁 - 贾平凹\n3. 解忧杂货店 - 东野圭吾\n4. 三体（全集） - 刘慈欣\n5. 湖畔 - 东野圭吾\n6. 无人生还 - 阿加莎·克里斯蒂\n7. 2015年度300问：心理 - 知乎\n8. 嫌疑人X的献身 - 东野圭吾\n9. 神探伽利略 - 东野圭吾\n10. 腾讯传1998-2016：中国互联网公司进化史\n11. 恶意 - 东野圭吾\n12. 时间的形状：相对论史话 - 汪洁\n13. 分歧者 - 维罗妮卡·罗斯\n14. 黑石之墓 - 克莱尔·麦克福尔\n15. 白夜行 - 东野圭吾\n16. 十一种孤独 - 理查德·耶茨\n17.  地狱变 - 蔡骏\n18. 我有故事，你有酒吗？ - 关东野客\n19. 芳华 - 严歌苓\n20. 天才在左，疯子在右\n21. 假面饭店 - 东野圭吾\n22. 放学后 - 东野圭吾\n23. 流星之绊 - 东野圭吾","tags":["小说"],"categories":["读书"]},{"title":"2017专业书单","url":"%2F2017%2F01%2F05%2F2017booklist%2F","content":"\n这里要放2017年读过的书单~\n\n<!-- more -->\n\n####    JAVA核心技术 卷I（卷2没看）\n\n> 我的入门java的第一本书\n\n####    剑指offer\n\n> 面试必备呀，刷了好几遍，打算下次面试之前在刷一次\n\n####    深入理解Java虚拟机\n\n > 还是面试必备啊，面试官特别喜欢问这里面的JVM知识，不过，确实是了解JVM最经典的书了。\n\n\n####    Effecttive Java 中文版（第二版）\n\n> 讲如何规范的写Java，里面很多前人的经验值得借鉴，感觉是一本可以读很多遍，每次读都能发现新大陆的书\n\n####    大型分布式网站架构 设计与实践 - 陈康贤\n\n > 讲了分布式业界常见的解决方案，算是一本不错的科普书。\n","tags":["读书"],"categories":["读书"]}]