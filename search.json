[{"title":"线程池中的阻塞队列知识点总结","url":"%2F2019%2F05%2F11%2Fjava-executors-blocking-learning%2F","content":"\n本文主要从线程池出发，具体了解一下其使用的各种不同的阻塞队列底层「放入」和「取出」是如何实现的。最后，具体介绍同步阻塞队列`SynchronousQueue`的底层实现和在线程池中的应用。\n\n通过本文：我可以收获到的是----一个线程池参数：阻塞队列的相关知识。多看源码多思考，秋招offer少不了。hhhhh\n\n❤️------------------❤️\n\n<!--more -->\n\n## 线程池中的阻塞队列知识点总结\n\n队列是线程池创建的一个重要参数，java提供了几种不同数据结构实现的阻塞队列，应对不同的线程池需求要选取适合的队列作为参数。\n![阻塞队列](http://pic.menduo.xyz/20190511232556.png)\n\n\n### 几种阻塞队列简要介绍\n\n- `ArrayBlockingQueue`：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 `数组`\n- `LinkedBlockingQueue`：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列 `链表`\n- `SynchronousQueue`：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 `队列和栈两种`\n- `PriorityBlockingQueue`：一个具有优先级的无限阻塞队列。`堆`\n\n\n### 线程池中的阻塞队列的一些思考\n\n1. 线程池中的阻塞队列是做什么的？\n2. 队列里放入和取出的操作有很多，线程池用了阻塞队列的哪两个方法？\n3. 阻塞队列可以放入Null吗？\n4. 无界阻塞阻塞队列长度真的是无大小限制的吗？\n5. 阻塞队列的put和take如果自己写应该如何实现？\n\n#### 1. 线程池中的阻塞队列是做什么的？\n\n用于存放实现了`Runnable接口`的可以被`工作线程worker`执行的`任务task`。四种不同的阻塞队列分别可以对应多种不同的实际使用场景。\n\n#### 2. 队列里放入和取出的操作有很多，线程池用了阻塞队列的哪两个方法？\n\n看线程池的源码会发现是`offer()`和`remove()`，对，没错！用了两个非阻塞的方法。。。如果是有界阻塞队列，在队列满了的情况下执行`offer()`将`command`放入阻塞队列，会直接返回`false`。看下面的代码：\n```java\n    public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) { //① offer\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command)) //② remove\n                reject(command);\n            else if (workerCountOf(recheck) == 0) \n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false)) //加入队列失败，在放worker试试，不行再拒绝也不晚。（worker弹性扩容）\n            reject(command);\n    }\n```\n\n`offer()`和`remove()`方法，在成功的时候会返回`true`,放入失败则返回`false`。所以这个是一种非阻塞的模式。为什么是非阻塞的`offer()`和`remove()`而不是使用阻塞的`put`和`take`？\n\n**A：** 我是这样考虑的，如果放不下就阻塞，那么会出现大量提交`task`线程堆积阻塞的情况，而线程池就是为了复用线程，它只是为了用几个一直运行的`worker`线程去调用实现`Runnable接口`的对象的`run()`方法。所以在队列放不下的情况应该直接返回，对于失败的情况应该自己用拒绝策略去处理。这样提交task的线程就不会产生堆积。`run()`是无返回的，不用阻塞，`call()`有自己的处理机制，可以阻塞。\n\n#### 3. 阻塞队列可以放入Null吗？\n\n`null` 被用来作为 `poll` 操作失败的返回值，为了避免这个操作产生二意性（poll一个空值，还是poll失败），所以不允许放入`null`。\n\n```java\n /*\n * <p>A {@code BlockingQueue} does not accept {@code null} elements.\n * Implementations throw {@code NullPointerException} on attempts\n * to {@code add}, {@code put} or {@code offer} a {@code null}.  A\n * {@code null} is used as a sentinel value to indicate failure of\n * {@code poll} operations.\n */\n```\n\n#### 4. 无界阻塞队列长度真的是无大小限制的吗？\n\n看了下`LinkedBlockingQueue`的构造函数,不设置初试长度，那么其值为整型的最大值。\n```java\n    public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node<E>(null);\n    }\n```\n\n#### 5. 阻塞队列的put和take如果自己写应该如何实现？\n\n最简单的方式就是使用`互斥锁+条件`的方式，定义锁的两个条件（1. 队列满；2. 队列空）。put方法当出现`队列满`放不下的情况时当前线程阻塞，等待take操作产生的唤醒操作。简单写了下代码如下：\n\n```java\npublic class BlockedQueue {\n    private int size = 3;\n    private ReentrantLock lock = new ReentrantLock(); // 锁\n    private Condition fullCondition = lock.newCondition(); \n    private Condition empyCondition = lock.newCondition();\n    private ArrayList<String> blockQ = new ArrayList<>();\n\n    public void put(String x) throws InterruptedException {\n        lock.lock(); //多个put的线程阻塞在这里\n        while (blockQ.size() >= size) {  // while 让获得锁的线程 阻塞在添加前，这样避免了死锁，换成if的话，它被唤醒的时候条件不成立导致add会出现超量的情况\n            fullCondition.await();\n        }\n        blockQ.add(x);\n        empyCondition.signal();\n        lock.unlock();\n\n    }\n\n    public String take() throws InterruptedException {\n        lock.lock();\n        String result = \"\";\n\n        while ((blockQ.size() <= 0)) {\n            empyCondition.await();\n        }\n        result = blockQ.remove(0);\n        fullCondition.signal();\n        lock.unlock();\n        return result;\n\n    }\n}\n```\n\n### 关于SynchronousQueue\n\n写完上面的代码之后，我在想的一个问题是:我在上面用`ReentrantLock`实现的阻塞队列的`put`和`take`操作用了`条件+双锁`的模式。这样阻塞的方式会造成的问题就在于如果同时多个线程去`put`数据，只会有一个线程获得锁，其他线程进入ReentrantLock的等待队列中等待被唤醒，这样会造成线程的频繁切换，消耗大量的CPU资源。\n\n线程池中的几种阻塞队列中，`ArrayBlockingQueue`,`LinkedBlockingQueue`,`PriorityBlockingQueue` 都是使用上面的`双锁`的方式实现的。\n\n而`SynchronousQueue`的实现却和上面几个阻塞队列的实现完全不同，它的实现方式是什么，为什么要这样子实现？\n\n#### 1. 理解SynchronousQueue是什么?\n\n`SynchronousQueue`同步阻塞队列，同步意味着放入和取出操作总是成对出现的，也就是说put一个object,就一定对应着一个take操作，配对成功两个线程才会继续运行。这样子抽象看的话就没有任何一个元素是放到队列里，队列一直处于一种又满又空的状态。这样子可以理解为同步阻塞队列的队列长度一直是0。\n\n所以`SynchronousQueue`的peek()为null,isEmpty()为true等等。\n\n```java\n    public E peek() {\n        return null;\n    }\n    public boolean isEmpty() {\n        return true;\n    }\n```\n\n\n其实理解什么是`SynchronousQueue`之后，我们可以用`ArrayBlockingQueue`设置队列长度为`1`来实现一个乞丐版的`SynchronousQueue`。这样做造成的两个问题：\n\n1. 就是频繁的加锁和解锁操作，涉及了线程频繁切换。\n2. 吞吐量只有1，线程池完全串行化了，没有办法进行并行操作。\n\n所以jdk6之后的采用了一种无锁算法来优化上面两个问题。\n\n无锁算法解决上面的问题：\n\n- 这种无锁算法(更多内容见参考资料)定义了两种数据结构。保证公平的FIFO队列，和非公平的LIFO栈。用来存储每一个put操作和take操作。\n- 队列和栈中保存的节点存在三种状态，REQUEST(消费者)，DATA（生产者），FULLFILLING(消费者和生产者匹配成功）。\n- put操作加入到队列中后，会进行自旋等待，直到有个take操作transfer自己put进来的元素。put线程和take线程才会返回。\n- 不用加锁的原因：在多线程下，每个线程可以通过状态来处理自己产生的状态（put or take），同时也可以处理其他线程产生的状态（帮助他移出fullfiling节点或者进行匹配），数据的状态以及CAS操作保证了多线程争用情况下的线程安全。具体看下面的代码。\n\n#### 2. SynchronousQueue的无锁同步算法\n\n用于保证put和take成对出现的核心方法就是transfer()，这个方法的语义：线程A把一个元素E交给线程B，或者线程A从线程B中拿到元素E。\n\n主要进行三种不同状态之间的变换：\n\n1. head节点状态和当前要加入的节点状态相同（都是生产者或者都是消费者），则要把当前线程作为节点加入到栈中，并更新head指向当前节点（考虑竞争情况下，使用原子的CAS操作）\n2. 如果head节点是不是fullfilling,则将当前节点标记Fullfiling状态并加入到栈中，更新head节点和匹配节点的match值。然后返回结果就可以了，自己可以不用处理队列状态了。\n3. 如果当前节点是fullfiling节点，移出fullfilling以及和它match的成对节点，下个额循环在处理自己这个节点。\n\n> 下面的代码是非公平的栈的实现：\n\n```java\nE transfer(E e, boolean timed, long nanos) {\n            //栈的模式\n            SNode s = null; // constructed/reused as needed\n            int mode = (e == null) ? REQUEST : DATA;  //REQUEST:请求拿到一个值，DATA请求放一个值\n\n            for (;;) {\n                SNode h = head;\n                if (h == null || h.mode == mode) {  // empty or same-mode\n                    if (timed && nanos <= 0) {      // can't wait\n                        if (h != null && h.isCancelled())\n                            casHead(h, h.next);     // pop cancelled node\n                        else\n                            return null;\n                    } else if (casHead(h, s = snode(s, e, h, mode))) { //cas操作将当前节点设置到head\n                        SNode m = awaitFulfill(s, timed, nanos); //自旋、阻塞等匹配的节点\n                        if (m == s) {               // wait was cancelled\n                            clean(s);\n                            return null;\n                        }\n                        if ((h = head) != null && h.next == s)\n                            casHead(h, s.next);     // help s's fulfiller\n                        return (E) ((mode == REQUEST) ? m.item : s.item);\n                    }\n                } else if (!isFulfilling(h.mode)) { // try to fulfill\n                    if (h.isCancelled())            // already cancelled\n                        casHead(h, h.next);         // pop and retry\n                    else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {\n                        for (;;) { // loop until matched or waiters disappear\n                            SNode m = s.next;       // m is s's match\n                            if (m == null) {        // all waiters are gone\n                                casHead(s, null);   // pop fulfill node\n                                s = null;           // use new node next time\n                                break;              // restart main loop\n                            }\n                            SNode mn = m.next;\n                            if (m.tryMatch(s)) {\n                                casHead(s, mn);     // pop both s and m\n                                return (E) ((mode == REQUEST) ? m.item : s.item);\n                            } else                  // lost match\n                                s.casNext(m, mn);   // help unlink\n                        }\n                    }\n                } else {                            // help a fulfiller\n                    SNode m = h.next;               // m is h's match\n                    if (m == null)                  // waiter is gone\n                        casHead(h, null);           // pop fulfilling node\n                    else {\n                        SNode mn = m.next;\n                        if (m.tryMatch(h))          // help match\n                            casHead(h, mn);         // pop both h and m\n                        else                        // lost match\n                            h.casNext(m, mn);       // help unlink\n                    }\n                }\n            }\n        }\n\n```\n#### 3. 线程池里是如何使用SynchronousQueue?\n\n线程池的工厂类`Executors`创建的`CachedThreadPool`的队列选择就是`SynchronousQueue`。`CachedThreadPool`线程池的特性就是弹性的扩张，当有`task`进来的时候，就会分配一个`worker`来运行这个`task`;如果没有可用`worker`就会new一个新的`worker`。当`worker`空闲一段时间后，还会自动销毁。\n\n##### 3.1. 首先看一下创建`CachedThreadPool`的工厂方法。默认情况下,核心池大小为0（初始化不创建worker）。核心池设置为最大值。`worker`存活时间为60s。阻塞队列为`SynchronousQueue`\n\n```java\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n```\n\n##### 3.2. 然后我一直在想的一个问题是，`SynchronousQueue`队列长度为0，`SynchronousQueue`的`offer`操作如果碰到`队列满`的情况会直接返回`false`。所以在线程池工作最开始的时间是`没有woker`的情况,`offer`操作一定都是返回`false`的。线程池如何处理这个`offer`进来的`task`的?\n\n**A:**看了下源码：在`①`这个位置根据上面`SynchronousQueue`的特性如果明确知道这里的判断为`false`，所以走了`②`，`add`了一个新的`worker`。\n\n```java\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) { //①\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false)) //②\n            reject(command);\n    }\n```\n\n##### 3.3. worker线程处理完一个任务之后也会进行offer操作，所以这个时候它会阻塞住吗？(这个问题蠢吗。。我其实想了好久才想明白的)\n\n**A:** 看源码可以发现是会阻塞住，会在`SynchronousQueue`中加入一个`take`节点,他会等待一个`offer`节点match自己。同时`keepAliveTime`woker的存活时间也是在这里发挥的作用。\n\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n\n        for (;;) {\n            //...略\n            try {\n                //①\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n\n## 参考资料\n1. [非阻塞实现](http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html)\n2. [非阻塞算法简介](https://www.ibm.com/developerworks/cn/java/j-jtp04186/)\n3. [SynchronousQueue简介](https://www.cnblogs.com/duanxz/p/3252267.html)\n4. [源码分析-SynchronousQueue](https://blog.csdn.net/u011518120/article/details/53906484)\n","tags":["BlockingQueue"],"categories":["Java"]},{"title":"项目中java创建子进程造成的I/O阻塞问题定位和解决","url":"%2F2019%2F04%2F27%2Fjava-runtime-execute-inputstream-blocking%2F","content":"\n记录一个bug的debug过程，bug起因是`后台调度程序`启动一个异步任务去调用一个docker容器包裹的工具服务（mutation变异测试工具），正常运行的情况下docker容器会正常的退出并自我销毁。而这次的现象是docker容器没有退出而一直处于运行状态。\n\n❤️------------------❤️\n\n<!-- more -->\n\n## 原因分析\n\n### docker下手\n分析`docker`未停止的原因大概率是docker所做的事情没有结束。所以，`docker exec`进入容器，用`jps`查看`Java进程`状态，果然发现进程并没有运行结束。\n\n### 观察java进程\n\n1. `jps`观察现象，有两个java进程在运行，`pid=430`就是我们的主进程，`pid=300`是主进程内新启动的一个子进程。\n```bash\n300 MutationTestMinion\n430 Jps\n```\n2. `jstask [pid]` 查看两个进程的线程栈。 \n**查看主进程的线程栈日志如下:**\n![主进程](http://pic.menduo.xyz/20190501204936.png)\n**查看子进程的线程栈日志如下:**\n![子进程](http://pic.menduo.xyz/20190501212950.png)\n**现象：**\n主线程正在读取inputStream,子线程正在写入outputStream。两个进程均阻塞住，无法继续运行。\n\n### 分析代码\n\n1. 拉代码，本地定位到具体的关键代码如下（比查bug更痛苦的就是查别的的bug了）\n```java\nString[] commands = {\"bash\", \"-c\", commandStr};\nProcess p = Runtime.getRuntime().exec(commands);\noutput = IOUtils.toString(p.getInputStream());\n``` \n\n2. 查看`Process`的文档和各种博客：\n\n**收集的有用的信息：**\n- 创建`Process`方式有两种： ① `ProcessBuilder`; ② `Runtime`.\n- 创建的`Process`没有自己的终端和控制台，他们的`标准I/O（stdin,stdout,stderr）`会被重定向给父进程，为此Process提供了方法`getOutputStream()`,`getInputStream()`,`getErrorStream()`来实现这个功能。\n- **重点：** 由于各平台对于标准I/O 设置了有限制的缓冲区大小。导致写入缓冲区可能会发生阻塞或者死锁的现象！！！原文：\n``` java\n /*\n * The parent process uses these streams to feed input to and get output\n * from the subprocess.  Because some native platforms only provide\n * limited buffer size for standard input and output streams, failure\n * to promptly write the input stream or read the output stream of\n * the subprocess may cause the subprocess to block, or even deadlock.\n */\n```\n\n## Bug详细解释\n\n通过上面的逐步分析，已经可以明显的知道原因是什么了：\n\n`子进程`在执行的过程中会向标准I/O的缓冲区中写入`标准输出`和`错误输出`，而主进程没有对子进程的`错误输出`进行处理，导致子进程发现`错误输出`缓冲区满了的时候自己阻塞住，无法继续运行。而主进程因为子进程无法运行结束，所以`getInputStream()`一直认为还会有数据，会一直等待来自子进程的`标准输出`，所以也阻塞在了`getInputStream()`。 程序中没有任何的超时机制，java进程阻塞住，所以docker也就阻塞住了。\n\n## 解决&引入新的bug \n\n关键点就是 要及时处理子进程的`标准输出`和`错误输出`,因此我们可以启动两个线程分别去处理两个输出，然后主进程等待子进程运行结束就可以了，关键代码如下：\n```java\nExecutorService single = Executors.newCachedThreadPool(); //启动个线程池\nFuture<String> errorOutput = single.submit(() -> IOUtils.toString(p.getErrorStream()));\nFuture<String> inputOutput = single.submit(() -> IOUtils.toString(p.getInputStream()));\nsingle.shutdown(); // 这里一定要主动关闭线程池。\np.waitFor(); //主线程挂起，等子进程结束\noutput = inputOutput.get(); // 获取输出结果\n```\n程序首先启动了一个线程池，添加了两个任务分别去处理标出输出和错误输出。然后关闭线程池，拒绝新的任务加入进来，主进程等待子进程运行结束后，再去获取线程池中的线程中的运行输出结果。\n\n我在写这个代码的时候引入了一个新的bug,就是没有手动关闭线程池,导致我有一段时间怀疑我之前看的文档和bug分析是不是错的，所以又去复现了一波，发现处理任务的子进程已经运行结束了，主进程park在了`ThreadPoolExecutor.getTask()`, 线程池在确认没有任务加入的时候一定要手动关闭`shutdown()`,否则会导致主进程因为有后台线程在运行的缘故，无法运行结束，造成的结果也是docker阻塞住，其实就是线程池在等待处理新的task而进行的自旋阻塞。幸好因为面试看过线程池源码，确认是线程池阻塞在等待任务的问题。所以多看源码还是对自己很有帮助的，有机会再总结一波线程池相关的源码分析。\n![线程池阻塞](http://pic.menduo.xyz/20190502153421.png)\n\n\n## 后记\n\n1. 关于线程池状态的说明\n\n```java\n/*  -1 RUNNING:  Accept new tasks and process queued tasks 可以接受新的任务并处理\n*   0 SHUTDOWN: Don't accept new tasks, but process queued tasks 不再接受新的任务，但是会处理完队列里的所有任务\n*   1 STOP:     Don't accept new tasks, don't process queued tasks, \n*             and interrupt in-progress tasks 不在接受任务，也不处理队列里的任务，同时中断正在处理任务\n*   2 TIDYING:  All tasks have terminated, workerCount is zero,\n*             the thread transitioning to state TIDYING\n*             will run the terminated() hook method 所有任务终止，worker数为0 线程改变状态为TIDYING \n*   3 TERMINATED: terminated() has completed 终止方法运行完成\n*/\n```\n\n\n2. 为什么这里线程池需要手动shutdown，直接看源码发现，线程池会不断的去获取`task`放入`worker`执行的代码是一个for死循环，其中的退出条件:\n   - 线程池状态码 >= SHUTDOWN 并且 （状态 >= STOP || 队列里没任务) 这个看上面的状态码就可以理解了，我们手动调用shutdown的原因就是这个\n   -  从队列里获取一个task,获取成功则返回\n\n```java\nprivate Runnable getTask() {\n        //...略\n        for (;;) {\n            int c = ctl.get(); \n            int rs = runStateOf(c); //获取线程池状态\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            //...略\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n## 参考资料\n\n1. Java doc\n2. [Process.getInputStream()阻塞问题](https://blog.csdn.net/yuanzihui/article/details/51093375)\n","tags":["开发"],"categories":["Java"]},{"title":"一道笔试题的思考:基本类型和包装类型进行数据比较的问题总结","url":"%2F2019%2F04%2F21%2Fint-with-integer%2F","content":"\n昨天阅文的一道笔试题，让仔细解释一下 `int`和`Integer`各种不同数据比较的问题，我发现自己能说出来的东西挺少的。阿里一面面试官说我了解知识的深度不够的问题，确实让我想了很多，其实我给自己的`特质`定位应该是可以迅速发现问题并解决、可以很快的举一反三，但是很少会因为这个问题去思考到底是底层是因为什么，也就是说`总结反思`的能力太差了，说白了还是修炼不到位，平时太懒了。\n\n所以以后遇到的每个问题都要认真的记录下来。争取秋招拿offer!\n\n<!-- more -->\n\n对于这个问题，首先有个**装箱**和**拆箱**的概念要首先被明确。也就是基本类型和包装类型可以相互转化。\n\n### 什么是装箱和拆箱？\n\n对于每一个基本类型都会有一个对应的包装类型。例如`int`的包装类型就是`Integer`。而拆箱动作就是将包装类型转化为基本类型，装箱动作就是将基本类型变成包装类型。\n\n#### 对应的API,以Integer为例：\n- 基本类型 --> 包装类型 Integer i = Integer.valueOf(int);\n\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)]; \n        //常量池缓存。[-128,127 or high] 默认127\n        //其中缓存池high大小可通过参数『java.lang.Integer.IntegerCache.high』进行调整,\n        //最大为Integer.MAX_VALUE - 128 - 1 \n    return new Integer(i);\n}\n```\n\n- 包装类型 --> 基本类型 int ii = i.intValue();\n\n``` java\npublic int intValue() {\n    return value;\n}\n```\n**总结：装箱操作就是调用包装类型的valueOf ;拆箱操作就是调用包装类型的xxValue()**\n\n#### Java可以做到自动拆箱和装箱\n\n> 在java中已经实现了自动拆箱和装箱的操作。\n\n> 时机：当任何一个操作中混用了基本类型和装箱类型，装箱类型就会进行拆箱操作。\n\n\n### 总结几个混合使用的要点\n\n#### 一些简单的测试用例进行解释整个 int和Integer进行比较的总结：\n\n- int 和 Integer进行混合比较时，Integer会进行拆箱操作变成基本类型。\n- Integer xx  = 1 这种会调用valueOf自动装箱。\n- Integer进行new操作的对象是放到堆上的。\n- Integer 调用valueOf返回的对象，分两种情况：① -128 <= x <= 127 返回的常量池缓冲区的对象 ② x > 128 会在堆上new一个新的对象 (只考虑默认的情况)\n\n#### 具体的几个测试用例\n```java\n    public static void main(String[] args) {\n        int a0 = 1;\n        int b0 = 128;\n        Integer a1 = 1;\n        Integer b1 = 128;\n        Integer a2 = new Integer(1);\n        Integer a3 = Integer.valueOf(1);\n        Integer b3 = Integer.valueOf(128);\n        Integer a4 = Integer.valueOf(1);\n        Integer b4 = Integer.valueOf(128);\n        System.out.println(a0 == a1); //true 首先a1返回的是常量池中的对象，又因为和int进行比较所以进行拆箱操作\n        System.out.println(b0 == b1); //true 同上，但是会在堆上new一个新的对象然后自动拆箱\n        System.out.println(a1 == a2); //false 首先 a1是缓存在常量池的对象，a2是在堆上new的对象\n        System.out.println(a3 == a2); //false a3返回的是放在常量池中的对象，两个对象不是同一个\n        System.out.println(a3 == a1); //true 返回都是常量池的中的对象，比较地址相等\n        System.out.println(a3 == a4); //true 返回都是常量池进行缓存过的对象，比较地址相等\n        System.out.println(b3 == b4); //false 两个堆上新new对象，具体看valueOf源码，在上面\n        System.out.println(a0 == a4); //true 拆箱比较\n        System.out.println(b0 == b4); //true 拆箱\n        System.out.println(b1 == b4); //false 装箱返回new的堆上对象 和 new的堆上对象\n    }\n```","tags":["基础知识"],"categories":["Java"]},{"title":"FileZip导致的JVM崩溃问题分析","url":"%2F2019%2F03%2F10%2Ffilezip-cause-jvm-crush-md%2F","content":"\n3.10 爬起床查日志，改bug.T_T.\n<!-- more -->\n\n## ZipFile 导致JVM奔溃现象分析\n\n### 现象：\n1. 日志无任何异常产生，但是服务进程已经死掉。定位到日志最后一行线程调用了`OnlineJudgeControler`，因此怀疑是慕码社区的代码（也就是我的锅T_T）导致的崩溃\n2. 查看JVM崩溃日志`hs_err_pid**.log`，发现down机时，线程发出了SIGBUS信号，线程停在了ZipFile对代码包解压上。搜索了一下网上关于这方面的解释。\n\n### 原因\n具体原因就是：我的一个接口会去下载一个压缩包到一个特定的目录，然后在解开这个压缩包（这个文件被映射到了系统内存），但是如果此时另外一个线程也执行这个接口就会将这个压缩包重写（改写了硬盘文件）。导致第一个解压过程出现异常（因此此时会发现自己已经被另外一个线程改变了），从而导致了JVM直接崩溃。\n\n**这里解释一下mmap内存机制：**\n\n我们知道直接对磁盘上的内容会比从内存中读去慢很多，mmap内存文件映射其实就是将磁盘上的一个文件映射到内存中的作用。进程通过对内存的修改来达到对文件的修改，因此mmap系统调用常常用于进程间共享内存方式的系统调用。\n\n**官方给出的关于mmap导致JVM崩溃的解释：**\n\nDisabling mmap Usage (on Solaris or Linux) This release includes a new system property, sun.zip.disableMemoryMapping, which allows the user to disable the mmap usage in Sun's java.util.zip.Zipfile implementation (on Solaris and Linux platforms). Solaris or Linux applications that use java.util.zip.ZipFile may experience a SIGBUS VM crash if the application accidentally overwrites any zip or jar files that are still being used by the same Java runtime. Although this is a programming error of the offending application, this system property provides a solution to avoid the VM crash. With the property set to true (-Dsun.zip.disableMemoryMapping=true, or simply -Dsun.zip.disableMemoryMapping) the Sun JDK/JRE runtime disables the mmap usage and the VM crash that might otherwise occur by overwriting the jar or zip file can be avoided.\n\n\n### 解决方法\n\n1. 官方说明的那样对zip禁用mmap\n> 在启动参数中加入-Dsun.zip.disableMemoryMapping=true \n2. 对代码进行修改，防止多个进程访问同一个文件，可以考虑加锁，或者对该文件进行备份，每个线程访问不同的文件\n\n\n### 参考资料\n\n> 参考资料1 https://blog.csdn.net/zqixiao_09/article/details/51088478\n> 参考资料2 https://my.oschina.net/shipley/blog/979231","tags":["日志"],"categories":["JVM"]},{"title":"headfirst设计模式-工厂和抽象工厂笔记","url":"%2F2018%2F12%2F03%2Fhead-first-1-factory%2F","content":"\n> 设计模式-工厂和抽象工厂。\n> github: [https://github.com/DmuMenDuo/JAVADesignPattern](https://github.com/DmuMenDuo/JAVADesignPattern/tree/master/src/xyz/menduo/factory)\n\n<!-- more -->\n\n## 工厂模式\n\n等到运行时才会知道去实例化哪个，工厂模式也是对设计原则中的将变化与不变化分离的典型应用。\n\n### 简单工厂模式\n\n**什么时候用简单工厂模式？**\n\n发现出现大量的条件判断去创建不同`instance`的对象的时候就可以考虑用工厂将其进行封装了。判断的理由就是这段代码出现了变化，所以要进行封装进行提取。\n\n简单工厂模式UML图：\n![简单工厂模式uml图](http://pic.menduo.xyz/20181130192703.png)\n\n\n### 静态工厂模式\n\n**静态工厂模式：**\n\n> 静态工厂模式只不过是将简单工厂模式的工厂变成了静态类 \n\n**静态工厂的优点和缺点？**\n\n> 优点：工厂无需实例化\n> 缺点：工厂无法通过继承来改变方法的行为。\n\n### 工厂模式\n\n![工厂UML图](http://pic.menduo.xyz/20181202152129.png)\n\n父类提供一个抽象方法，子类负责实现，这个实现的内容就是一个工厂在产生对象的过程。\n![工厂](http://pic.menduo.xyz/20181113154209166559267.png)\n\n\n**工厂模式定义：**\n\n工厂模式是用来封装'对象创建'使用的模式，他通过声明一个抽象父类让子类决定应该去创建什么具体对象。\n![工厂模式-2018111815425544733044.png](http://pic.menduo.xyz/2018111815425544733044.png)\n\n\n**简单工厂和工厂模式的区别？**\n\n工厂模式是创建了一种框架（父类定义，子类实现new对象）。而简单工厂没有。所有工厂模式比简单工厂更加有弹性。\n\n**工厂模式有什么好处？**\n\n封装了变化。代码可以重复利用，方便维护。\n\n\n### 抽象工厂模式\n我理解的`抽象`这个词的含义是，这个工厂类没有具体指明是什么具体的工厂，而是一组工厂，用来实例化一组产品组，或者实例化一个产品的各个部分。\n\n![20181118154255459072470.png](http://pic.menduo.xyz/20181118154255459072470.png)\n\n\n### 对比一下工厂模式和抽象工厂模式\n\n1. 工厂模式采用的继承的方式，父类定义个抽象方法，子类去实现。这个实现的过程就是去创建自己需要的对象。\n2. 抽象工厂是定义一个公共接口，每一个接口都是一个要实例化对象的方法。抽象工厂在使用的时候会被当成属性注入需要实例化的地方。","tags":["设计模式"],"categories":["设计模式"]},{"title":"青海小憩","url":"%2F2018%2F08%2F10%2Fqinghai5day%2F","content":"\n距离开学还有一个月的时间，一次去参加会议的偶然机会，就有了这次的青海五日游。\n刚刚好的季节，刚刚好的行程。吃过了最好吃的羊肉，喝过了最好喝的酸奶，看过了最好看的天。人生也就不过如此吧！\n\n\n\n<!-- more -->\n\n\n\n##### 旅行前的准备\n\n其实要准备的东西也没有什么的，最重要的保命物品就是`防晒霜`!!!。不管男生女生这个真的很重要，我滴妈，我没带被晒得老惨了，褪了一层皮；带一件`外套`和`长裤`，那边早上和晚上还是挺冷的。emmmmm.可以带双`拖鞋`，天空之境还是蛮漂亮的，如果要去盐湖的话可以带双拖鞋准备下水用。还有就是`相机`,那边太漂亮啦，只恨自己拍照技术太渣，手机像素太渣。\n\n##### 第一天：西宁市: 青海省博物馆 -- 东关清真寺 -- 莫家街\n到了西宁一定要去试一下当地的手撕羊肉和老酸奶，实在而且超级好吃，反正我们是安顿好住宿就去找手撕羊肉了。之后去了一下青海省博物馆，它也在西宁市内而且没有门票费，如果想去了解当地文化的话可以去那里转转；因为那边穆斯林比较多，所以清真寺也会比较多，东关清真寺应该当地最大的一座清真寺了，里面还有人讲解穆斯林文化；最后就是晚上去莫家街找吃的，这条小吃街还是蛮有名的，好像正好赶上那边的美食节，所以吃的很满足。\n![西宁市内](http://pic.menduo.xyz/20181113154207578552083.jpg)\n\n##### 第二天：塔尔寺 -- 拉脊山 -- 青海湖二郎剑\n塔尔寺，藏传佛教的圣地。\n<!-- ![塔尔寺](http://pic.menduo.xyz/20181113154207665760536.jpg) -->\n![塔尔寺](http://pic.menduo.xyz/20181113154207693250517.jpg)\n逛过塔尔寺之后就准备去青海湖二郎剑啦，中间穿过了拉脊山，最高海拔4500多米，讲道理还是会有高原反应的，不过司机建议是不要吸氧气，适应适应就好啦。下面的照片就是在拉脊山上拍的。\n![拉脊山](http://pic.menduo.xyz/20181113154207816952435.jpg)\n青海湖二郎剑景区，图1是在船上拍到的，可以看见的阳光。图二叫经幡，当地牧民用来祈求福运隆昌，消灾灭殃。\n![青海湖二郎剑](http://pic.menduo.xyz/20181113154207873353621.jpg)\n之后住宿的地方可以选择黑水镇，不过我们没有订到，所以去了很远的石乃亥，以至于去天空之境的时候多走了一段重复的路。不过路上风景很美所以不会很无聊。\n##### 第三天：石乃亥 -- 天空之境\n本来是有安排看日出的，不过很遗憾的是在石乃亥的两天早上都是阴天还下了小雨，到九点多才晴天。不过还好到天空之境，也就是卡茶盐湖的时候，天气很给面子。\n![天空之境-卡茶盐湖](http://pic.menduo.xyz/20181114154212694423885.jpg)\n其实我们的行程蛮充裕的。以至于在青海湖旁边的草原上玩了一下午。和小伙伴们跳到缺氧。。。。\n![青海湖旁不知名草场](http://pic.menduo.xyz/20181114154212697758897.jpg)\n##### 第四天：回到西宁市\n第四天就是回到西宁市准备开会啦。中间去了原子城学习了一下，抱着学习的目的所以就没拍照片了，然后就是季节有点晚要不然可以看到成片的油菜花海。我们去的时候已经没有了。\n\n\n-- end -- \n\n\n","tags":["青海"],"categories":["旅行"]},{"title":"使用Docker-Java动态的获取Container的log日志","url":"%2F2017%2F12%2F13%2Fget-log-from-docker-container%2F","content":"\ndocker-java 是 JAVA 操作Docker Remote API 的一个工具。最近项目需要读取容器的运行日志出来。记录一下自己遇到的问题。更多其他的问题可以参考他们的测试用例。\n> github地址: [docker-java](https://github.com/docker-java/docker-java) 目前版本 3.0.13\n\n<!-- more -->\n\n### 准备工作\n#### 1. 首先要开启docker的客户端 (我电脑 ubuntu16.04)\n\n```bash\n#查看配置文件位于哪里\nsystemctl show --property=FragmentPath docker \n#编辑配置文件内容，接收所有ip请求\nsudo gedit /lib/systemd/system/docker.service  \nExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://127.0.0.1:8787\n# 这样配置的目的是可以通过http的方式进行远程访问，如果不需要的话可以通过自带的sock方式本地访问\n#重新加载配置文件，重启docker daemon\nsudo systemctl daemon-reload     \nsudo systemctl restart docker \n\n```\n\n#### 2. 建工程 && pom.xml引入依赖\n\n```xml\n<dependency>\n  <groupId>com.github.docker-java</groupId>\n  <artifactId>docker-java</artifactId>\n  <version>3.0.13</version>\n</dependency>\n```\n\n### 获取容器实时运行结果\n\n\n> 通过查看容器日志的方式,\n> 设置一个回调函数，重写onNext(),就可以取到运行的结果了\n\n```java\ndockerClient.logContainerCmd(dockerId).withStdOut(true).withStdErr(true)\n                    .exec(new LogContainerResultCallback(){\n                        @Override\n                        public void onNext(Frame item) {\n                            super.onNext(item);\n                            System.out.println(\"容器运行的结果：\"+item.toString())\n                        }\n                        @Override\n                        public void onComplete() {\n                            super.onComplete();\n                        }\n                    }).awaitCompletion();\n```\n\n> `awaitComletion()`就是让查日志进程阻塞，直到进程调用onComlete()\n> 最好等容器停止后再去读，因为容器在运行中可能还没产生日志，但callback读的时候以为读完了，直接执行onComplete就结束了，因此没有输出。 所以建议查日志前，检查一下容器运行情况，代码如下：之后一直循环判断直到容器停止就可以了\n\n```java\n\t//获取容器的运行状态\n\tdockerClient.inspectContainerCmd(dockerId).\n                exec().getState().getRunning();\n```\n\n\n","tags":["bug解决"],"categories":["docker"]},{"title":"翻译文章:JVM架构简析","url":"%2F2017%2F10%2F10%2Ftrans-jvm-structure%2F","content":"\n\n每个JAVA开发者都知道字节码将会被**JRE**（java运行时环境）所执行，但是许多人不知道的是**JRE**是**java虚拟机**（JVM）分析字节码，解释代码，以及执行它的那部分实现。对于一个开发者来说知道了解JVM的架构是非常重要的，因为它可以让我们更有效地编写代码。在这篇文章，我们将更深入的了解java中的**JVM架构**以及JVM的**不同组成部分**。\n\n> 原文地址：https://dzone.com/articles/jvm-architecture-explained\n\n<!--more-->\n\n----------\n\n## JVM架构简析\n\n\n> 一个JVM不同组成部分的综述，以及和其相关的一些图表\n\n![20181119154259959133032.png](http://pic.menduo.xyz/20181119154259959133032.png)\n\n### 什么是JVM？\n\n一个**虚拟机**是一个物理机的软件实现。java开发的概念是**WORA（一次编写到处运行）**，所以运行在**虚拟机**上。**编译器**编译java文件生成**.class**文件。然后**.class**文件被放入到一个可以加载执行他的虚拟机中。下面是一个JVM 架构的图。\n\n### JVM是如何工作的？\n\n在上述的架构图中，JVM被分成了三个主要的子系统：\n\n1. 类加载子系统。\n2. 运行时数据区域。\n3. 执行引擎。\n\n#### 1. 类加载子系统\n\njava的动态类加载机制在类加载子系统中被处理。由它加载，连接，以及在**运行时**第一次引用类时初始化类文件，而不是在**编译时**。\n\n##### 1.1. 加载\n\n类们将会被这个组件加载。BootStrap 类加载器 ，Extension 类加载器，和Application类加载器将会帮助完成这个过程。\n\n1.  **BootStrap类加载器** - 它的责任是加载那些启动相关路径里的类，不仅仅只是rt.jar。最高的优先权被给于给这个加载器。\n\n2.  **Extension类加载器** - 它的责任是加载那些包含在**jre/lib下的ext**文件夹内的类。\n\n3.  **Application类加载器** - 他的责任是加载**用户定义的classpath下**以及路径涉及的环境变量等等里面的类。\n\n上述的**类加载器**都遵循**双亲委派模型**去加载类文件。\n\n##### 1.2 连接\n\n1.  **验证 **- 字节码验证器将会验证生成的字节码是否正确，如果验证失败那么我们将得到一个验证错误。\n\n2.  **准备** - 为所有静态变量分配内存并且设置初始值。\n\n3.  **解析** - 所有的符号引用将会被替换成方法区的直接引用。 \n\n##### 1.3 初始化\n\n这是类加载的最后时期，这时候所有的静态变量都会被赋予初值，并且执行类中的静态块。\n\n\n#### 2. 运行时数据区\n\n运行时数据区被分成了五个主要部分：\n\n\n- **方法区** - 所有**类相关数据**将会被存储在这里，包括静态变量。每一个JVM只有一个方法区，所以它中的资源是被共享的。\n- **堆** - 所有的**对象**以及他们相关的**实例化变量和数组**被存储在这里。每一个JVM也只有一个堆。因为**方法区**和**堆**是线程间共享的，因此数据的存储**不是线程安全**的。\n- **栈** - 对于每个线程，都将创建一个单独的**运行时栈**。对于每一个**方法调用**，一个被叫做**栈桢**的实体将会在栈内存中被创建。所有的**局部变量**将会在栈空间被创建。栈空间是线程安全的因为它不共享资源。栈桢被分成如下三个子部分：\n    - **局部变量表** - 涉及方法的所有**本地变量**以及和他相关的值被储存在这里。\n    - **操作数栈** - 如果需要执行任何中间操作，**操作数栈**扮演者运行时工作空间的作用去执行这些操作。\n    - **桢数据** - 该方法对应的所有符号都存储在这里。在任何**异常**情况下，捕获块信息将在帧数据中维护。\n- **程序计数器** - 每一个线程都有一个独立的**程序计数器**，来保存**当前指令地址**，一旦指令执行完成就**更新**程序计数器为下一条指令地址。\n- **本地方法栈** - 本地方法栈保存本地方法信息。对于每一个线程，一个独立的本地方法栈将会被创建。\n\n#### 3. 执行引擎\n\n分配到**运行时数据区**的字节码会被执行引擎执行。执行引擎读取字节码并逐步的执行。\n\n-  **解释器** -  解释器可以很快的解释字节码，但是却执行的很慢。解释器的一个缺点就是当一个方法被调用多次后，每次都需要重新被解释。\n-  **实时编译器** - 实时编译器弥补了解释器的不足。执行引擎将在转换字节代码时使用解释器的帮助，但是当它发现重复的代码时，它使用的是JIT编译器，它编译整个字节码并将其更改为本地代码。这种本地方法将会直接被使用在重复的方法调用上，来提升系统的性能。\n    - **中间代码生成器** - 生成中间代码。\n    - **代码优化器** - 负责优化上面生成的中间代码。\n    - **目标代码生成器** - 负责生成机器代码或本地代码\n    - **分析器** - 一个特殊的组件，负责找热点，例如，是否一个方法被多次调用等等。\n\n- **垃圾收集器** - 收集以及移除未被引用的对象。垃圾回收将会被这个\"**System.gc()**\"调用触发,但是这个执行时不确定的。JVM的垃圾收集器收集被创建的对象。\n\n**Java Native Interface (JNI)**: **JNI**将与**本地方法库**交互，并提供执行引擎所需的本地库。\n**本地方法库**:它是执行引擎所需的本地库的集合。\n","tags":["JVM"],"categories":["java"]},{"title":"2018年专业书单","url":"%2F2017%2F09%2F12%2F2018booklist%2F","content":"\n软狗不是每天都在搬砖的！！！ 我爱学习~\n\n今年要补些本科落下的基础知识了。面试时候遇到的JAVA相关的知识。毕设要用到Docker和机器学习算法也学一下。 软狗要全栈（除了前端\n<!-- more -->\n\n####  JAVA并发编程艺术\n\n> java并发的一些基础知识，以及J.U.C的一些常用类。PS：新买的，在火车上看了1/3就丢了，现在只能啃电子书。很真实。。。mmp\n\n\n#### JAVA8函数式编程\n\n> 强烈推荐，如果想快速上手Java8,学会Lamda，这是一本好书，很薄，代码也可以在github下载到\n\n#### Docker技术入门与实战\n\n> 一本关于docker的工具书。\n\n\n####  Effecttive Java 英文版（第三版）\n\n> 第三版相对于第二版多了很多JAVA8的内容，由于还没有中文版，所以只能读英文的了\n\n#### 机器学习\n\n> 读论文的时候发现很多人在用机器学习的算法，周大牛的机器学习是必备的吧 \n\n\n\n\n","tags":["读书"],"categories":["读书"]},{"title":"2018年娱乐书单","url":"%2F2017%2F09%2F12%2F2018booklist2%2F","content":"\n经常被说文盲，多读书是好呀，和别人聊天可以找找话题~\n\n\n\n<!-- more -->\n\n1. 未来简史 `看不懂看不懂...`\n2. 白金数据 `算不算马上就成为现实的故事？或者已经是现实了？`\n3. 从0到1:开启商业与未来的秘密 `我觉得从投资人的角度对于一个好创业公司的讲解很透彻，应该如何看待创业公司，以及创业公司应该如何生存法则。`\n4. 这世界既残酷也温柔 `我觉得很无聊的一本书,没什么值得借鉴的营养故事,装逼史:北大-->留学-->买比特币-->财务自由-->持续创业。不过抓住机会的能力还是要学习的`\n5. 摆渡人 `超级治愈的一本书`\n6. 摆渡人2 `感觉没有上一部写的好，对于苏珊珊的结局，我不喜欢作者这样处理她，不剧透，23333`\n7. 一只特立独行的猪 `这是一本充斥着个人观点的书，对待任何的事情都要有自己的态度，要会为自己的观点坚持，这就是王小波吧。一个幽默，有个性的老人儿`\n8. 梦幻花 `关于一株不存在的致幻花的故事，真的很佩服东野圭吾，总可以在恰到好处的时候将所有的片段结成一个完整的故事。`\n9. 虚无的十字架 `我认为是一本十分矛盾的书，每个人都是在弥补自己曾经的过错去做另一件更错的事。书中的很多思想关于判刑对一个人以及其周围的影响，冲击着日本目前的法律制度。可能是因为之前的江歌案吧，日本的法律真的可以宽恕罪行。`\n10. 刺杀骑士团团长 `一开始以为书中的我产生了人格分裂，那个骑士团长以及斯巴鲁男人是他的两重人格，后来......书一直围绕着那幅可以救赎的刺杀骑士团长的画展开，不过结局矛盾的人全部得到了自己想要的答案真好啊。`\n11. 刺 `一本关于校园暴力，职场暴力以及网络暴力的书，文中想表达的思想全在字面上，很容易读懂。佩服作者敢于发声。`\n12. 高情商聊天术`记不得讲什么了，反正现在看感觉什么都没说`\n13. 毕业 `东野圭吾的小说总是很吸引人...其实不打算看的，但还是一口气看完了。可能脑子比较笨，经常猜不到结局才喜欢看的吧`\n14. 秘密 `又一本东野圭吾的书，在读到一半的时候猜到了我最不喜欢的结局！！！`4\n15. 龙族(1-4） `江南的小说还是很好看的！`\n16. 人月神话 `软件需求课的作业`","tags":["小说"],"categories":["读书"]},{"title":"2017娱乐书单","url":"%2F2017%2F01%2F05%2F2017booklist2%2F","content":"\n2017年小说书单\n\n<!-- more -->\n\n1. 不正常人类症候群 - 张寒寺\n2. 浮躁 - 贾平凹\n3. 解忧杂货店 - 东野圭吾\n4. 三体（全集） - 刘慈欣\n5. 湖畔 - 东野圭吾\n6. 无人生还 - 阿加莎·克里斯蒂\n7. 2015年度300问：心理 - 知乎\n8. 嫌疑人X的献身 - 东野圭吾\n9. 神探伽利略 - 东野圭吾\n10. 腾讯传1998-2016：中国互联网公司进化史\n11. 恶意 - 东野圭吾\n12. 时间的形状：相对论史话 - 汪洁\n13. 分歧者 - 维罗妮卡·罗斯\n14. 黑石之墓 - 克莱尔·麦克福尔\n15. 白夜行 - 东野圭吾\n16. 十一种孤独 - 理查德·耶茨\n17.  地狱变 - 蔡骏\n18. 我有故事，你有酒吗？ - 关东野客\n19. 芳华 - 严歌苓\n20. 天才在左，疯子在右\n21. 假面饭店 - 东野圭吾\n22. 放学后 - 东野圭吾\n23. 流星之绊 - 东野圭吾","tags":["小说"],"categories":["读书"]},{"title":"2017专业书单","url":"%2F2017%2F01%2F05%2F2017booklist%2F","content":"\n这里要放2017年读过的书单~\n\n<!-- more -->\n\n####    JAVA核心技术 卷I（卷2没看）\n\n> 我的入门java的第一本书\n\n####    剑指offer\n\n> 面试必备呀，刷了好几遍，打算下次面试之前在刷一次\n\n####    深入理解Java虚拟机\n\n > 还是面试必备啊，面试官特别喜欢问这里面的JVM知识，不过，确实是了解JVM最经典的书了。\n\n\n####    Effecttive Java 中文版（第二版）\n\n> 讲如何规范的写Java，里面很多前人的经验值得借鉴，感觉是一本可以读很多遍，每次读都能发现新大陆的书\n\n####    大型分布式网站架构 设计与实践 - 陈康贤\n\n > 讲了分布式业界常见的解决方案，算是一本不错的科普书。\n","tags":["读书"],"categories":["读书"]}]