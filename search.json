[{"title":"TimSort遇到Comparator抛出异常IllegalArgumentException的那些事儿","url":"%2F2019%2F08%2F04%2Ftimsort%2F","content":"\n最近组里面在一起学习java开发规范，其中遇到的一点就是Comparator一定要满足对称性和传递性，类似于重写equals方法一样的方式。这是为什么呢？\n\n<!--more-->\n下面是Java开发规范中的描述：\n\n> 在 JDK7 版本及以上，Comparator 实现类要满足如下三个条件，不然 Arrays.sort，Collections.sort 会抛 IllegalArgumentException 异常。\n> 说明:三个条件如下:\n> 1) x，y 的比较结果和 y，x 的比较结果相反。 对称性\n> 2) x>y，y>z，则 x>z。传递性\n> 3) x=y，则 x，z 比较结果和 y，z 比较结果相同。\n\n```Java\n    //反例\n    new Comparator<Student>() {\n        @Override\n        public int compare(Student o1, Student o2) {\n            return o1.getId() > o2.getId() ? 1 : -1;\n        }\n    }\n```\n​\n### 1.先说结论：\n\n1. 归并排序过程会出现`原数组S`中的`部分有序数组A`和`有序数组B`, `A`和`B`会进行merge成一个`整体有序`的`数组S`。\n\n2. 归并排序的优化过程对于`比较函数不满足条件的比较`会出现`悖论`，即比较过程中出现` B[m] < A[n] < A[n+1] < B[m]`，出现这个过程就是`compare方法`错误，排序算法识别出来这个问题，被`throw`出去了,这个异常就是 `java.lang.IllegalArgumentException: Comparison method violates its general contract!` 比较函数不合规。\n\n3. **为什么jdk6以前没出现问题，jdk7之后会出现问题？**jdk6以前是使用传统的归并排序并没有严格的检查，而jdk7以后使用TimSort算法,其中做了多处优化并进行了严格检查。\n\n### 2.参考资料：\n\n结合源码以及自己实际测试，下面两篇文章可以进行参考。\n\n1. https://linsky328.iteye.com/blog/2382272 \n\n2. https://www.coder4.com/archives/4092\n\n### 3.出现原因分析：\n\n`Arrays.sort`使用的排序算法`TimSort`,这个算法是二分插入排序和优化版的归并排序的结合使用的排序算法。时间复杂度会比O(nlogN)要快，很多主流的编程语言的内置排序算法都是`TimSort`\n\n#### 3.1 TimSort的基本原理：\n\nTimSort 是一种基于二分插入排序和归并排序相结合的方式的排序算法。将待排序数组分成一个个的minLen段，对minLen段用二分插入排序排好放入栈中，然后对栈中的排好序的minLen段进行归并排序。\n\n##### 3.1.1 二分插入排序\n\n这里也有个优化，在去切分minLen段的时候，并不是一开始就从起始位置执行二分插入排序，而是先找到最长的升序和降序段，如果长度过长直接放入栈中等待归并，如果太短，才会去执行二分插入。\n\n![3.1.1](https://i.loli.net/2019/08/04/JGoLinWKxzOREVP.png)\n\n##### 3.1.2 归并排序\n\n它用了两个栈`runLen`和`runBase`来维护归并过程：第一个栈保存了每个块的长度(runLen)，第二个栈保存了每个块在原数组中的起始位置(runBase)\n\n**问题：什么时候进行归并?**\n\n整个归并的逻辑代码就是下面这块：\n\n```java\n// 栈中元素>=3个的时候，如果第一个小于第三个块\nprivate void mergeCollapse() {\n    while (stackSize > 1) {\n      int n = stackSize - 2;\n      if (n > 0 && runLen[n-1] <= runLen[n] + runLen[n+1]) {\n        if (runLen[n - 1] < runLen[n + 1])\n          n--;\n        mergeAt(n);\n      } else if (runLen[n] <= runLen[n + 1]) {\n        mergeAt(n);\n      } else {\n        break; // Invariant is established\n      }\n    }\n}\n```\n\n我一开始没理解，所以画了下面两张图来帮助理解，用一句话概括就是归并的非递归实现也要把过程想象成一颗递归树，同等level的才进行合并。\n\n- 栈中出现三个块的情况首先判断：\n\n![1](https://i.loli.net/2019/08/04/WQrj67UtVmGbJiC.png)\n\n- 栈中只有两个块的情况，分两种：\n\n 1. 第一种`Len(n) <= Len(n+1)` 那么第一个块是没被合并过的，赶紧合并掉。\n\n 2. 第二种就是Len(n)很大，说明之前合并过，和Len(n+1)不属于一个level，暂时不合并，break。\n\n- 具体的merge过程\n\n    1. 块A 和 块B 首先执行第一处优化:找到base2在块A中的位置，前面的均比base2小，后面的均比base2大。去掉块A中比base2小的元素（去头），同理块B去掉比块A尾部都大的元素（去尾），这个过程我们可以得到**第一个条件**`A[base1] > B[base2]`  (**gallopRight应用比较函数**: `compare(B[base2],A[base1]) >= 0 == false）` 得到下面这张图：\n\n    ![](https://i.loli.net/2019/08/04/gRmCPZhYcQELioz.png)\n\n    2. 之后进行正常的归并的merge操作，当发生块A或者块B的比较多次胜利后，会触发优化，直接找到base2在块A中的位置，然后移动cursor1到新的位置，然后把块B全部拷贝到到了A中，触发**第二个条件** `B[base2] > A[base1+1]` （这时在查询应用到的比较函数是：`(compare(A[base1+1],B[base2]) <= 0 == true)）` **gallopLeft函数**\n\n    ![](https://i.loli.net/2019/08/04/yvs61OctYSmQLIh.png)\n    \n    ![](https://i.loli.net/2019/08/04/IijTdgC34eNKWho.png)\n    \n\n 3. 根据最初的条件 `A[base1] < A[base1+1]`,我们可以得出 `B[base2] < A[base1] < A[base1+1] < B[base1]` 。 这个时候的特征就是`cursor2 == -1 `并且`len(tmp) == 0 `所以抛异常\n\n    ```java\n    else if (len2 == 0) {\n        throw new IllegalArgumentException(\n                \"Comparison method violates its general contract!\");\n    }\n    ```\n\n    上面直接用的参考资料里的图，我自己也亲自做了测试，确实会发生上面的情况，导致cursor2  = -1 len2 = 0的情况\n\n\n### 4.最后总结：\n\n其实最根本的问题在于`compare函数`的使用上。在最后merge过程中`compare(A,B)>=0` 和 `compare(B,A) < 0` 这两个是无法等价的。所以产生了悖论，抛异常，告知这个比较方法是错误的","tags":["归并排序"],"categories":["Java"]},{"title":"批量保存的一些思考","url":"%2F2019%2F07%2F22%2Fbatch-save-intern%2F","content":"\n最近实习一直在不停的接各种小需求做，这次就是导师给的一个任务，解决目前系统批量查询接口慢而且重复代码过多的问题，如何设计一个简洁又通用的方案。\n\n<!-- more -->\n\n### 1.问题\n\n查询接口目前有两种： 1. 单个数据查询 2. 批量数据查询。 但他们都或多或少存在一些问题。\n\n1. 单个数据查询接口如果进行批量的数据查询就只能在外面包一层`for`循环。这样执行sql会造成大量的磁盘的IO操作，性能很差。for循环查mysql，公司是明令禁止的，一定要写批量操作查询。\n\n2. 如果改用批量数据查询，那么对于大批量数据的查询，在`Mysql`用到的`in语句`就会有大量的参数，`Mysql`执行语句的长度有大小限制，并且我们知道`in`在包含大量参数的执行上，效率不是很高 (见参考文献)。\n\n**为什么直接批量全部数据不好？** 数据库的连接是要通过连接池的，每一个`db操作`都会占用一个连接，如果这个批量数据的接口并发量很高的话，会对同时需要访问数据库的其他`db操作`造成干扰。如果用`for循环`的方式一个一个查询，又会造成自己的查询过慢的情况。所以选择一种折中的方案\n\n**如何统一分散到各个方法中的分片逻辑？** 目前项目中的批量查询都是`传入List传出List的方法函数`，想到了写一个分片的util，传入一个方法函数返回这个函数的返回结果。\n\n### 2.方案\n\n所以有了一种折中的解决方案: 对查询进行分片，分批进行查询，最后进行结果聚集。这样可以**减少IO次数**并且可以**限制in中参数的个数**。\n\n第一个版本批量查询接口的主要功能就是先进行分片，之后对分片数据执行传入的函数得到分片结果，最后对分片的结果进行聚集成最后的结果并返回。\n\n![2](https://i.loli.net/2019/07/22/5d35b5facb85f75788.png)\n\n我在想这个方法的优化时候，首先想到的就是这个过程特别像`mapreduce`的过程。先`partition`之后`map`分批运算最后进行`reduce`。所以这个过程我觉得是可以进行`并行`的。第二点就是传入的参数是`List<Integer>`，不能支持批量查询Long类型的参数，例如我将要写的批量接口就是根据bigint类型的查询， 所以我改成下面这种形式：(返回Steam会不会灵活性更好一点？可以转List,可以转Set)\n\n![2.1](https://i.loli.net/2019/07/22/5d35b62d4fbbc80535.png)\n\n### 3.测试\n\n那么改成这种方式，效率真的提高了吗？\n\n做个测试，假设每一次请求大致会花费100ms。这个过程可以用线程阻塞来模拟。所以用了sleep。\n\n![3](https://i.loli.net/2019/07/22/5d35b6404e6de59146.png)\n\n串行查询代码如下，串行批量查询接口：`104094ms`\n\n```java\n    //执行时间104094\n    public static void main(String[] args) {\n        List<Integer> list = Lists.newArrayList();\n        for (int i = 0; i < 1000; i++) {\n            list.add(i);\n        }\n        long start = System.currentTimeMillis();\n        List<Integer> list2 = findByIds(list,10, LoopUtils::add);\n        System.err.println(System.currentTimeMillis() - start);\n    }\n```\n\n并行查询代码如下，并行批量查询接口：`14664ms`\n\n```java\n    //执行时间14664\n    public static void main(String[] args) {\n        List<Integer> list = Lists.newArrayList();\n        for (int i = 0; i < 1000; i++) {\n            list.add(i);\n        }\n        long start2 = System.currentTimeMillis();\n        List<Integer> list1 = findByIdsParallel(list, 10,ids ->LoopUtils.add(ids).stream());\n        System.err.println(System.currentTimeMillis() - start2);\n    }\n```\n并行是和CPU核数相关的，和想象中的差不多，我的MBP是8C的 ，并行比串行大致快了7倍左右。\n\n**上面的测试其实没有说明什么本质上的问题：**\n\n1. 单个接口单个测试，没有模拟并发的场景。\n2. 用Thread.sleep()代替db操作\n\n### 4.新的问题\n\n1. **结果是乱序的**。如果对查询结果有顺序要求，那么就要对结果进行排序。例如很多查询结果get(0)的操作就不适合用parallel了\n\n2. **CPU爆满效率可能不如串行**。真实的场景中，8核理论上都是在被使用的，如果全部爆满的情况下，因为多了更多的线程切换操作，可能运行效率还不如串行执行。\n\n### 5.参考资料\n\n1. https://blog.csdn.net/shooke/article/details/56673523 一个博主关于in中传入不同参数数量的查询时间的测试。大意就是in中个数越多，查询越慢？但是为什么？\n\n2. 看到以一种嵌套查询的解释，https://www.cnblogs.com/wxw16/p/6105624.html时间复杂度是O(N + N*M)，但是对于直接传入List.size() = M,那么查询效率就是O(M)，其实对于几百个参数的查询还是可以接受的\n\n3. https://www.jianshu.com/p/bd825cb89e00 parallelStream背后的男人ForkJoinPool。\n\n4. http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html when to use parallelStream\n\n","tags":["优化"],"categories":["Java"]},{"title":"一个lambda的表达式是如何在java中执行的","url":"%2F2019%2F07%2F11%2Flambda-in-java%2F","content":"\n实习的过程中，发现项目中大量的使用了Lambda的写法来提高开发效率。一直很好奇它底层到底是如何实现的？为什么可以把一个函数当做一个参数来进行传递和执行？ \n\n<!-- more -->\n\n\n## 1.一个lambda函数是如何被执行的：\n\n### 1.1一个简单的demo源代码如下：\n\n这是一段简单的测试代码，包含了一个`lambda`函数，其中`HelloWorldLambda`是我定义的一个函数式接口,在这个接口的里面只包含一个抽象方法方法`hello`。\n```java\npublic class Main {\n    public static void main(String[] args) {\n         HelloWorldLambda helloWorldLambda = () -> System.out.println(\"hello menduo\");\n         helloWorldLambda.hello();\n    }\n}\n```\n### 1.2编译阶段：三个需要注意的点\n\n1. `lambda`表达式被编译生成了静态内部方法`lambda$main$0`\n ![1](http://pic.menduo.xyz/20190711003954.png)\n2. 调用`lambda`处，生成`lambda`的字节码执行指令 : `invokedynamic #2,0 // InvokeDynamic #0:hello:()LHelloWorldLambda;`。 \n![2](http://pic.menduo.xyz/20190711004404.png)\n3. 这里的`#0`指的是编译生成的`Boostrap Method`：后面的是需要用到的参数，也就是实现`lambda`的接口对应的方法\n![3](http://pic.menduo.xyz/20190711004421.png)\n\n### 1.3执行阶段：\n1. `invokedynamic #2` ==> 执行`BoostrapMethods` 的 `0`。⬆️上图\n\n2. 可以看到,他是一个 `invokestatic指令`。执行了一个静态方法`LambdaMetafactory.metafactory(...)`\n\n3. `LambdaMetafactory.metafactory(...)`  会执行`buildCallSite()` 返回一个`CallSite`，`CallSite`是一个方法句柄。\n![1.3.3](http://pic.menduo.xyz/20190711004538.png)\n \n1. `buildCallSite()` 主要做的事情就是，1.用asm生成一个实现lambda函数接口的代理类;2.然后返回一个方法句柄，就是lambda生成的静态方法的代理方法的句柄。\n```java\n@Override\nCallSite buildCallSite() throws LambdaConversionException {\n    final Class<?> innerClass = spinInnerClass(); //1\n    if (invokedType.parameterCount() == 0) {\n        final Constructor<?>[] ctrs = //...略\n        try {\n            Object inst = ctrs[0].newInstance();\n            return new ConstantCallSite(MethodHandles.constant(samBase, inst)); //2\n        }\n    } else {\n        try {\n            UNSAFE.ensureClassInitialized(innerClass);\n            return new ConstantCallSite(\n                    MethodHandles.Lookup.IMPL_LOOKUP\n                            .findStatic(innerClass, NAME_FACTORY, invokedType)); //2\n        }\n    }\n}\n```\n最终 invokeinterface 查找调用点的方法表，执行下面代理方法。\n![](http://pic.menduo.xyz/20190711004742.png)\n\n## 2.相关的知识点\n\n### 2.1 方法句柄：MethodHandle\n\n#### 2.1.1 MethodHandle作用\n\nMethodHandle是一种拿到方法,并执行的手段，类似于反射机制拿到方法。\n\n#### 2.1.2 MethodHandle和反射拿到方法之间的不同\n\n1. 性能上考虑：`MethodHandle`比反射更迅速，访问检查是在创建时而不是在执行时进行的。（而且从下面的例子中看到，它操作的是字节码`findStatic`，而反射拿到方法的是在`java代码层`面上)\n\n2. 灵活性考虑：反射要更加的灵活。`MethodHandle`没有列举类中成员，获取属性访问标志之类的机制。（就只有`findXXX`\n\n#### 2.1.3 MethodHandle使用\n\n1. 方法在哪里。methodHandle.Lookup指定的类\n2. 方法名是什么。第二个参数\n3. 方法的参数签名和返回类型。 MethodType\n\n一个`methodhandle`的小例子: MethodType 的第一个参数是返回类型，后面的是方法签名参数上的类型\n```java\npublic class MethodHandleMain {\n    public static void main(String[] args) {\n        MethodHandles.Lookup  lookup = MethodHandles.lookup();\n        MethodType methodType = MethodType.methodType(Integer.class,Integer.class,Integer.class);\n        try {\n            MethodHandle methodHandle = lookup.findStatic(MethodHandleMain.class,\"sum\",methodType);\n            Integer x = (Integer) methodHandle.invoke(1,2);\n            System.out.println(x);\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n    }\n    private static Integer sum(Integer a, Integer b) {\n        return a + b;\n    }\n}\n```\n\n### 2.2 字节码生成：ASM\n\n#### 2.2.1 ASM框架：\n\nASM是一个字节码操作的框架。可以动态的生成和修改字节码文件\n\n#### 2.2.2 用途：\n\n1. lambda表达式的解析。（这里用到了\n2. cglib动态代理类的生成。\n3. jacoco插桩也会用到。\n\n#### 2.3 虚拟机指令：invokedynamic, invokeinterface,invokestatic...\n\n\n| 指令 |说明 |\n| --- | --- |\n|invokeinterface |用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。（Invoke interface method）|\n|invokevirtual | 指令用于调用对象的实例方法，根据对象的实际类型进行分派（Invoke instance method; dispatch based on class）|\n|invokestatic | 用以调用类方法（Invoke a class (static) method ）|\n|invokespecial | 指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。（Invoke instance method; special handling for superclass, private, and instance initialization method invocations ）|\n|invokedynamic | JDK1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在JVM内部，而invokedynamic则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。(Invoke dynamic method) |\n\n\n## 4.附录：打印完整的字节码文件 javap -p -v LambdaMain2.class\n```java\nClassfile /Users/menduo/IdeaProjects/menduodemo/target/classes/LambdaMain2.class\n  Last modified 2019-7-9; size 1179 bytes\n  MD5 checksum 7597c1d01af4829107e2659b508fbc77\n  Compiled from \"LambdaMain2.java\"\npublic class LambdaMain2\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #8.#25         // java/lang/Object.\"<init>\":()V\n   #2 = InvokeDynamic      #0:#30         // #0:hello:()LHelloWorldLambda;\n   #3 = InterfaceMethodref #31.#32        // HelloWorldLambda.hello:()V\n   #4 = Fieldref           #33.#34        // java/lang/System.out:Ljava/io/PrintStream;\n   #5 = String             #35            // hello menduo\n   #6 = Methodref          #36.#37        // java/io/PrintStream.println:(Ljava/lang/String;)V\n   #7 = Class              #38            // LambdaMain2\n   #8 = Class              #39            // java/lang/Object\n   #9 = Utf8               <init>\n  #10 = Utf8               ()V\n  #11 = Utf8               Code\n  #12 = Utf8               LineNumberTable\n  #13 = Utf8               LocalVariableTable\n  #14 = Utf8               this\n  #15 = Utf8               LLambdaMain2;\n  #16 = Utf8               main\n  #17 = Utf8               ([Ljava/lang/String;)V\n  #18 = Utf8               args\n  #19 = Utf8               [Ljava/lang/String;\n  #20 = Utf8               helloWorldLambda\n  #21 = Utf8               LHelloWorldLambda;\n  #22 = Utf8               lambda$main$0\n  #23 = Utf8               SourceFile\n  #24 = Utf8               LambdaMain2.java\n  #25 = NameAndType        #9:#10         // \"<init>\":()V\n  #26 = Utf8               BootstrapMethods\n  #27 = MethodHandle       #6:#40         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #28 = MethodType         #10            //  ()V\n  #29 = MethodHandle       #6:#41         // invokestatic LambdaMain2.lambda$main$0:()V\n  #30 = NameAndType        #42:#43        // hello:()LHelloWorldLambda;\n  #31 = Class              #44            // HelloWorldLambda\n  #32 = NameAndType        #42:#10        // hello:()V\n  #33 = Class              #45            // java/lang/System\n  #34 = NameAndType        #46:#47        // out:Ljava/io/PrintStream;\n  #35 = Utf8               hello menduo\n  #36 = Class              #48            // java/io/PrintStream\n  #37 = NameAndType        #49:#50        // println:(Ljava/lang/String;)V\n  #38 = Utf8               LambdaMain2\n  #39 = Utf8               java/lang/Object\n  #40 = Methodref          #51.#52        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #41 = Methodref          #7.#53         // LambdaMain2.lambda$main$0:()V\n  #42 = Utf8               hello\n  #43 = Utf8               ()LHelloWorldLambda;\n  #44 = Utf8               HelloWorldLambda\n  #45 = Utf8               java/lang/System\n  #46 = Utf8               out\n  #47 = Utf8               Ljava/io/PrintStream;\n  #48 = Utf8               java/io/PrintStream\n  #49 = Utf8               println\n  #50 = Utf8               (Ljava/lang/String;)V\n  #51 = Class              #54            // java/lang/invoke/LambdaMetafactory\n  #52 = NameAndType        #55:#59        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #53 = NameAndType        #22:#10        // lambda$main$0:()V\n  #54 = Utf8               java/lang/invoke/LambdaMetafactory\n  #55 = Utf8               metafactory\n  #56 = Class              #61            // java/lang/invoke/MethodHandles$Lookup\n  #57 = Utf8               Lookup\n  #58 = Utf8               InnerClasses\n  #59 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #60 = Class              #62            // java/lang/invoke/MethodHandles\n  #61 = Utf8               java/lang/invoke/MethodHandles$Lookup\n  #62 = Utf8               java/lang/invoke/MethodHandles\n{\n  public LambdaMain2();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n         4: return\n      LineNumberTable:\n        line 1: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   LLambdaMain2;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=1, locals=2, args_size=1\n         0: invokedynamic #2,  0              // InvokeDynamic #0:hello:()LHelloWorldLambda;\n         5: astore_1\n         6: aload_1\n         7: invokeinterface #3,  1            // InterfaceMethod HelloWorldLambda.hello:()V\n        12: return\n      LineNumberTable:\n        line 3: 0\n        line 4: 6\n        line 5: 12\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      13     0  args   [Ljava/lang/String;\n            6       7     1 helloWorldLambda   LHelloWorldLambda;\n\n  private static void lambda$main$0();\n    descriptor: ()V\n    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC\n    Code:\n      stack=2, locals=0, args_size=0\n         0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #5                  // String hello menduo\n         5: invokevirtual #6                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 3: 0\n}\nSourceFile: \"LambdaMain2.java\"\nInnerClasses:\n     public static final #57= #56 of #60; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles\nBootstrapMethods:\n  0: #27 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #28 ()V\n      #29 invokestatic LambdaMain2.lambda$main$0:()V\n      #28 ()V\n```\n\n## 5.参考\n\nhttps://www.infoq.cn/article/Invokedynamic-Javas-secret-weapon\n\nhttps://blog.csdn.net/zxhoo/article/details/38387141\n\nhttps://blog.csdn.net/kangkanglou/article/details/79422520\n\nhttps://www.jianshu.com/p/3ae6efff1c96 静态分派和动态分派","tags":["学习笔记"],"categories":["Java"]},{"title":"fastjson升级版本引发bug的思考","url":"%2F2019%2F07%2F04%2Ffastjson-update-sdk-bug%2F","content":"\n因为`fastjson`低版本的安全漏洞问题，所以公司所有服务全部要进行版本升级。\n\n给公司升级`fastjson`版本时候发现了一个问题，在老版本中`key`的类型只能是`String`，而在新版本中可以为任意`Object`类型。但是在获取`keySet()`时候静态检测结果只能允许返回`String`。所以造成了运行时强转类型失败的异常。\n\n<!-- more -->\n\n\n### 问题起因\n\n`JSON.parseObject()`的过程中老版本不会在乎你的`key`是什么类型，会直接`toString()`。而在新版本中增加了一个`特性开关`的选项：\n\n1. fastjson 1.2.29 中，在进行json解析成object的过程中，会直接把key的类型转成String.\n![pic1](https://i.loli.net/2019/07/04/5d1ce2a5d356444371.png)\n2. fastjson 1.2.58 中，增加了一个`feature: NonStringKeyAsString`，只有在进行`parse()`时,指定转成`String`的key才会进行转化。\n![pic2](https://i.loli.net/2019/07/04/5d1ce2e6f2bb298662.png)\n![pic3](https://i.loli.net/2019/07/04/5d1ce39af2f9683542.png)\n\n### 我的问题\n\n下面的代码在`fastjson1.2.58`的条件下，进行编译是可以通过的但是运行就会报出 `java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String` 这个错误。这是为什么？\n\n```java\npublic static void main(String[] args) {\n    JSONObject jsonObject =JSON.parseObject(\"{64:\\\"64\\\"}\");\n    //keySet()声明的返回类型确实是Set<String> 符合遍历条件\n    for (String x:jsonObject.keySet()) { \n        System.out.println(x);\n    }\n}\n```\n编译正确也就证明这段代码躲过了`Java的类型检查`。但是在运行过程中，发生了什么导致了**运行过程中得到的数据类型并不是声明的类型**。\n\n### 先说结论\n\n两个因素造成了这个问题： 1. 隐式的数据向上转换 2. 泛型擦除\n\n1. 隐式数据向上转换：\n    调用链中数据类型变化：`Map<String,Object> ---> Map ---> Object  最后---> Map<String,Object> `。问题就是,如果我在转换过程中Map存入的`key`是`Integer` 最后为什么会可以转成`Map<String,Object>`？\n\n2. 这个可以用`泛型擦除`进行解释，运行时JVM不感知你的Map类型，所以在向下强转的时候其实转的是`Map<Object,Object>` 。`keySet()`获取的也是`Set<Object>` 。**但是！！** `foreach`进行遍历的时候就要去指定类了，根据静态检测编译的结果，你这个位置一定要声明成`String`的父类才可以，声明成`Integer`肯定会报`编译错误`的。当指定一个实际为`Map<Integer,Object>` 的`key`为`String`时就会报`java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String`异常了。\n\n### 调试代码\n\n\n1. 简单写了一个出现问题的demo。进行上面思路的图文解释\n![小demo](https://i.loli.net/2019/07/04/5d1ce4b8c6c3255842.png)\n\n2. JSONObject 强转成Map类型。注意返回的是Object\n\n![2.1](https://i.loli.net/2019/07/04/5d1ce4d1de45528363.png)\n\n![2.2](https://i.loli.net/2019/07/04/5d1ce4e28421453210.png)\n\n![2.3](https://i.loli.net/2019/07/04/5d1ce4ef26d3540330.png)\n\n3. 断点位置获取的key = Integer \n\n![3](https://i.loli.net/2019/07/04/5d1ce500dc14460917.png)\n\n4. 存入之前的map。因为泛型类型被强转没了，所以可以存入\n\n![4](https://i.loli.net/2019/07/04/5d1ce535ac5d746962.png)\n\n5. 返回结过 ` object(或者说map)` -->向下强转 `JSONObject` 。由于JVM的泛型擦除，在运行时是没有任何泛型标识的，所以可以强转成功。JSONObject中的map其实是`Map<Object,Object>`\n![5](https://i.loli.net/2019/07/04/5d1ce55171b3515352.png)\n\n\n6. 然后在调用`keySet()`时候也是没有问题的，同样因为泛型擦除变成了`Set<Object>`的原因。 但是foreach时候就不一样了，foreach是要指定类型的，但是因为我们的强转，导致运行时的类型已经不再是我们声明的类型了。所以编译没有保存但是运行报错了。\n\n![6](https://i.loli.net/2019/07/04/5d1ce57d1068952924.png)\n\n\n### 最后，放一个可以复现Demo\n\n#### 简易版demo 可以躲过静态类型检查，但运行报转换异常\n\n``` java\n    public static void main(String[] args) {\n        HashMap<String,Object> map = new HashMap();\n        Object object = parse(map); // 2️⃣ 类型第二次强转\n        HashMap<String,Object> map2 = new HashMap<>();\n        if(object instanceof HashMap) {\n            map2 = (HashMap)object; // 3️⃣ 类型第三次强转\n        }\n        map2.keySet(); // 这里并没有报异常\n//        for (Object x: map2.keySet()) { // 正确的代码。\n//            System.out.println(x);\n//        }\n        for (String x: map2.keySet()) { // 错误的代码。编译没报错，因为自己声明的时候key的类型就是String。 但是因为我们的向上强转，导致存入的是Integer(Object)\n            System.out.println(x);\n        }\n    }\n​\n    public static Object parse(final Map map){ // 1️⃣类型第一次强转\n        map.put(123,\"64\");\n        map.put(\"123\",\"64\");\n        return map;\n    }\n```\n#### 解决方案\n\n1. 遍历时候用Object肯定没问题。\n\n2. key尽量用标准的string。\n\n3. 打开特性开关，让fastjson转化key的类型为string。下面是一个demo:\n```java\nJSONObject jsonObject =JSON.parseObject(\"{64:\\\"64\\\"}\",Feature.NonStringKeyAsString); //开启转换开关。\n```\n**注：这个开关是在fastjson 1.2.42 时候才出现的，小于这个版本应该都不会出现强转的错误，高于这个版本的需要自己看看key是不是除了String的其他Object类型，是的话就要加上这个开关了。**\n![注](https://i.loli.net/2019/07/04/5d1ce5e861cdb40435.png)\n\n\n","tags":["fastjson"],"categories":["Java"]},{"title":"2019年看过的书单呀","url":"%2F2019%2F06%2F04%2F2019booklist%2F","content":"\n二十四向风吹过，一切皆空。\n\n<!-- more -->\n\n1. Redis设计与实现\n\n> 项目中用到了Redis，这本书对于Redis的一些原理性知识比较好，算是面试必考\n\n2. HeadFirst设计模式\n\n> 高级软件设计课程的教材。这本书通俗易懂很容易上手\n\n\n3. 重构-改善代码的既有设计 \n> 有一段时间觉得自己代码挺烂的，通过这本书了解到一些实用的重构技巧\n\n4. 布鲁克林有棵树 \n\n> 强烈推荐！！！ 这是一本关于成长的小说，也可以算上作者贝蒂史密斯的自传吧。在我最困难的时候给了我鼓励。让我相信所有的努力在天分面前并不是无用的。\n\n5. 坏血\n\n> 这个讲的是几年前的硅谷巨头医药公司希拉洛斯的故事。Fake it until you make it。 大环境确实造就了这种现象，但是没有人会一直被欺骗。\n\n6. 会消失的人\n\n> 米索的这本书，给我的感受就是。回想自己过去的24年（我还只有23年）。每一年能记住的就仅仅是那么几个片段：很小的时候的记忆就都没了，小学过年的欣喜，初中中考失利，高中的初恋，大学的忙碌。 二十四向风吹过，一切皆空。\n\n7. 一个人的好天气\n\n> 小清新的一本书，一个女孩的春夏秋冬。\n\n8. 高性能Mysql - 再看\n\n> 实习中大量涉及mysql相关知识，以前的项目几乎不用接触的东西现在要开始补洞了\n\n9. 伤心咖啡福馆之歌 - 再看\n\n> 地铁上的要看的\n\n10. 拉普拉斯的魔女\n   \n> 读的时候会在想如果我也有这种『预测』的能力。。。。\n\n11. 神的孩子全跳舞\n\n> 6个短篇的故事，文中充斥着孤独，空虚的情感，好在结局都是好的，最终都找到了阳光。\n\n12. 摆渡人3：无境之爱\n\n> 有始有终，摆渡人系列全看完了，结局还可以接受。","tags":["读书"],"categories":["读书"]},{"title":"线程池中的阻塞队列知识点总结","url":"%2F2019%2F05%2F11%2Fjava-executors-blocking-learning%2F","content":"\n本文主要从线程池出发，具体了解一下其使用的各种不同的阻塞队列底层「放入」和「取出」是如何实现的。最后，具体介绍同步阻塞队列`SynchronousQueue`的底层实现和在线程池中的应用。\n\n通过本文：我可以收获到的是----一个线程池参数：阻塞队列的相关知识。多看源码多思考，秋招offer少不了。hhhhh\n\n❤️------------------❤️\n\n<!--more -->\n\n## 线程池中的阻塞队列知识点总结\n\n队列是线程池创建的一个重要参数，java提供了几种不同数据结构实现的阻塞队列，应对不同的线程池需求要选取适合的队列作为参数。\n![阻塞队列](http://pic.menduo.xyz/20190511232556.png)\n\n\n### 几种阻塞队列简要介绍\n\n- `ArrayBlockingQueue`：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。 `数组`\n- `LinkedBlockingQueue`：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列 `链表`\n- `SynchronousQueue`：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 `队列和栈两种`\n- `PriorityBlockingQueue`：一个具有优先级的无限阻塞队列。`堆`\n\n\n### 线程池中的阻塞队列的一些思考\n\n1. 线程池中的阻塞队列是做什么的？\n2. 队列里放入和取出的操作有很多，线程池用了阻塞队列的哪两个方法？\n3. 阻塞队列可以放入Null吗？\n4. 无界阻塞阻塞队列长度真的是无大小限制的吗？\n5. 阻塞队列的put和take如果自己写应该如何实现？\n\n#### 1. 线程池中的阻塞队列是做什么的？\n\n用于存放实现了`Runnable接口`的可以被`工作线程worker`执行的`任务task`。四种不同的阻塞队列分别可以对应多种不同的实际使用场景。\n\n#### 2. 队列里放入和取出的操作有很多，线程池用了阻塞队列的哪两个方法？\n\n看线程池的源码会发现是`offer()`和`remove()`，对，没错！用了两个非阻塞的方法。。。如果是有界阻塞队列，在队列满了的情况下执行`offer()`将`command`放入阻塞队列，会直接返回`false`。看下面的代码：\n```java\n    public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) { //① offer\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command)) //② remove\n                reject(command);\n            else if (workerCountOf(recheck) == 0) \n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false)) //加入队列失败，在放worker试试，不行再拒绝也不晚。（worker弹性扩容）\n            reject(command);\n    }\n```\n\n`offer()`和`remove()`方法，在成功的时候会返回`true`,放入失败则返回`false`。所以这个是一种非阻塞的模式。为什么是非阻塞的`offer()`和`remove()`而不是使用阻塞的`put`和`take`？\n\n**A：** 我是这样考虑的，如果放不下就阻塞，那么会出现大量提交`task`线程堆积阻塞的情况，而线程池就是为了复用线程，它只是为了用几个一直运行的`worker`线程去调用实现`Runnable接口`的对象的`run()`方法。所以在队列放不下的情况应该直接返回，对于失败的情况应该自己用拒绝策略去处理。这样提交task的线程就不会产生堆积。`run()`是无返回的，不用阻塞，`call()`有自己的处理机制，可以阻塞。\n\n#### 3. 阻塞队列可以放入Null吗？\n\n`null` 被用来作为 `poll` 操作失败的返回值，为了避免这个操作产生二意性（poll一个空值，还是poll失败），所以不允许放入`null`。\n\n```java\n /*\n * <p>A {@code BlockingQueue} does not accept {@code null} elements.\n * Implementations throw {@code NullPointerException} on attempts\n * to {@code add}, {@code put} or {@code offer} a {@code null}.  A\n * {@code null} is used as a sentinel value to indicate failure of\n * {@code poll} operations.\n */\n```\n\n#### 4. 无界阻塞队列长度真的是无大小限制的吗？\n\n看了下`LinkedBlockingQueue`的构造函数,不设置初试长度，那么其值为整型的最大值。\n```java\n    public LinkedBlockingQueue() {\n        this(Integer.MAX_VALUE);\n    }\n\n    public LinkedBlockingQueue(int capacity) {\n        if (capacity <= 0) throw new IllegalArgumentException();\n        this.capacity = capacity;\n        last = head = new Node<E>(null);\n    }\n```\n\n#### 5. 阻塞队列的put和take如果自己写应该如何实现？\n\n最简单的方式就是使用`互斥锁+条件`的方式，定义锁的两个条件（1. 队列满；2. 队列空）。put方法当出现`队列满`放不下的情况时当前线程阻塞，等待take操作产生的唤醒操作。简单写了下代码如下：\n\n```java\npublic class BlockedQueue {\n    private int size = 3;\n    private ReentrantLock lock = new ReentrantLock(); // 锁\n    private Condition fullCondition = lock.newCondition(); \n    private Condition empyCondition = lock.newCondition();\n    private ArrayList<String> blockQ = new ArrayList<>();\n\n    public void put(String x) throws InterruptedException {\n        lock.lock(); //多个put的线程阻塞在这里\n        while (blockQ.size() >= size) {  // while 让获得锁的线程 阻塞在添加前，这样避免了死锁，换成if的话，它被唤醒的时候条件不成立导致add会出现超量的情况\n            fullCondition.await();\n        }\n        blockQ.add(x);\n        empyCondition.signal();\n        lock.unlock();\n\n    }\n\n    public String take() throws InterruptedException {\n        lock.lock();\n        String result = \"\";\n\n        while ((blockQ.size() <= 0)) {\n            empyCondition.await();\n        }\n        result = blockQ.remove(0);\n        fullCondition.signal();\n        lock.unlock();\n        return result;\n\n    }\n}\n```\n\n### 关于SynchronousQueue\n\n写完上面的代码之后，我在想的一个问题是:我在上面用`ReentrantLock`实现的阻塞队列的`put`和`take`操作用了`条件+双锁`的模式。这样阻塞的方式会造成的问题就在于如果同时多个线程去`put`数据，只会有一个线程获得锁，其他线程进入ReentrantLock的等待队列中等待被唤醒，这样会造成线程的频繁切换，消耗大量的CPU资源。\n\n线程池中的几种阻塞队列中，`ArrayBlockingQueue`,`LinkedBlockingQueue`,`PriorityBlockingQueue` 都是使用上面的`双锁`的方式实现的。\n\n而`SynchronousQueue`的实现却和上面几个阻塞队列的实现完全不同，它的实现方式是什么，为什么要这样子实现？\n\n#### 1. 理解SynchronousQueue是什么?\n\n`SynchronousQueue`同步阻塞队列，同步意味着放入和取出操作总是成对出现的，也就是说put一个object,就一定对应着一个take操作，配对成功两个线程才会继续运行。这样子抽象看的话就没有任何一个元素是放到队列里，队列一直处于一种又满又空的状态。这样子可以理解为同步阻塞队列的队列长度一直是0。\n\n所以`SynchronousQueue`的peek()为null,isEmpty()为true等等。\n\n```java\n    public E peek() {\n        return null;\n    }\n    public boolean isEmpty() {\n        return true;\n    }\n```\n\n\n其实理解什么是`SynchronousQueue`之后，我们可以用`ArrayBlockingQueue`设置队列长度为`1`来实现一个乞丐版的`SynchronousQueue`。这样做造成的两个问题：\n\n1. 就是频繁的加锁和解锁操作，涉及了线程频繁切换。\n2. 吞吐量只有1，线程池完全串行化了，没有办法进行并行操作。\n\n所以jdk6之后的采用了一种无锁算法来优化上面两个问题。\n\n无锁算法解决上面的问题：\n\n- 这种无锁算法(更多内容见参考资料)定义了两种数据结构。保证公平的FIFO队列，和非公平的LIFO栈。用来存储每一个put操作和take操作。\n- 队列和栈中保存的节点存在三种状态，REQUEST(消费者)，DATA（生产者），FULLFILLING(消费者和生产者匹配成功）。\n- put操作加入到队列中后，会进行自旋等待，直到有个take操作transfer自己put进来的元素。put线程和take线程才会返回。\n- 不用加锁的原因：在多线程下，每个线程可以通过状态来处理自己产生的状态（put or take），同时也可以处理其他线程产生的状态（帮助他移出fullfiling节点或者进行匹配），数据的状态以及CAS操作保证了多线程争用情况下的线程安全。具体看下面的代码。\n\n#### 2. SynchronousQueue的无锁同步算法\n\n用于保证put和take成对出现的核心方法就是transfer()，这个方法的语义：线程A把一个元素E交给线程B，或者线程A从线程B中拿到元素E。\n\n主要进行三种不同状态之间的变换：\n\n1. head节点状态和当前要加入的节点状态相同（都是生产者或者都是消费者），则要把当前线程作为节点加入到栈中，并更新head指向当前节点（考虑竞争情况下，使用原子的CAS操作）\n2. 如果head节点是不是fullfilling,则将当前节点标记Fullfiling状态并加入到栈中，更新head节点和匹配节点的match值。然后返回结果就可以了，自己可以不用处理队列状态了。\n3. 如果当前节点是fullfiling节点，移出fullfilling以及和它match的成对节点，下个额循环在处理自己这个节点。\n\n> 下面的代码是非公平的栈的实现：\n\n```java\nE transfer(E e, boolean timed, long nanos) {\n            //栈的模式\n            SNode s = null; // constructed/reused as needed\n            int mode = (e == null) ? REQUEST : DATA;  //REQUEST:请求拿到一个值，DATA请求放一个值\n\n            for (;;) {\n                SNode h = head;\n                if (h == null || h.mode == mode) {  // empty or same-mode\n                    if (timed && nanos <= 0) {      // can't wait\n                        if (h != null && h.isCancelled())\n                            casHead(h, h.next);     // pop cancelled node\n                        else\n                            return null;\n                    } else if (casHead(h, s = snode(s, e, h, mode))) { //cas操作将当前节点设置到head\n                        SNode m = awaitFulfill(s, timed, nanos); //自旋、阻塞等匹配的节点\n                        if (m == s) {               // wait was cancelled\n                            clean(s);\n                            return null;\n                        }\n                        if ((h = head) != null && h.next == s)\n                            casHead(h, s.next);     // help s's fulfiller\n                        return (E) ((mode == REQUEST) ? m.item : s.item);\n                    }\n                } else if (!isFulfilling(h.mode)) { // try to fulfill\n                    if (h.isCancelled())            // already cancelled\n                        casHead(h, h.next);         // pop and retry\n                    else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {\n                        for (;;) { // loop until matched or waiters disappear\n                            SNode m = s.next;       // m is s's match\n                            if (m == null) {        // all waiters are gone\n                                casHead(s, null);   // pop fulfill node\n                                s = null;           // use new node next time\n                                break;              // restart main loop\n                            }\n                            SNode mn = m.next;\n                            if (m.tryMatch(s)) {\n                                casHead(s, mn);     // pop both s and m\n                                return (E) ((mode == REQUEST) ? m.item : s.item);\n                            } else                  // lost match\n                                s.casNext(m, mn);   // help unlink\n                        }\n                    }\n                } else {                            // help a fulfiller\n                    SNode m = h.next;               // m is h's match\n                    if (m == null)                  // waiter is gone\n                        casHead(h, null);           // pop fulfilling node\n                    else {\n                        SNode mn = m.next;\n                        if (m.tryMatch(h))          // help match\n                            casHead(h, mn);         // pop both h and m\n                        else                        // lost match\n                            h.casNext(m, mn);       // help unlink\n                    }\n                }\n            }\n        }\n\n```\n#### 3. 线程池里是如何使用SynchronousQueue?\n\n线程池的工厂类`Executors`创建的`CachedThreadPool`的队列选择就是`SynchronousQueue`。`CachedThreadPool`线程池的特性就是弹性的扩张，当有`task`进来的时候，就会分配一个`worker`来运行这个`task`;如果没有可用`worker`就会new一个新的`worker`。当`worker`空闲一段时间后，还会自动销毁。\n\n##### 3.1. 首先看一下创建`CachedThreadPool`的工厂方法。默认情况下,核心池大小为0（初始化不创建worker）。核心池设置为最大值。`worker`存活时间为60s。阻塞队列为`SynchronousQueue`\n\n```java\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n```\n\n##### 3.2. 然后我一直在想的一个问题是，`SynchronousQueue`队列长度为0，`SynchronousQueue`的`offer`操作如果碰到`队列满`的情况会直接返回`false`。所以在线程池工作最开始的时间是`没有woker`的情况,`offer`操作一定都是返回`false`的。线程池如何处理这个`offer`进来的`task`的?\n\n**A:**看了下源码：在`①`这个位置根据上面`SynchronousQueue`的特性如果明确知道这里的判断为`false`，所以走了`②`，`add`了一个新的`worker`。\n\n```java\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        int c = ctl.get();\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        if (isRunning(c) && workQueue.offer(command)) { //①\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        else if (!addWorker(command, false)) //②\n            reject(command);\n    }\n```\n\n##### 3.3. worker线程处理完一个任务之后也会进行offer操作，所以这个时候它会阻塞住吗？(这个问题蠢吗。。我其实想了好久才想明白的)\n\n**A:** 看源码可以发现是会阻塞住，会在`SynchronousQueue`中加入一个`take`节点,他会等待一个`offer`节点match自己。同时`keepAliveTime`woker的存活时间也是在这里发挥的作用。\n\n```java\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n\n        for (;;) {\n            //...略\n            try {\n                //①\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n\n## 参考资料\n1. [非阻塞实现](http://www.cs.rochester.edu/research/synchronization/pseudocode/duals.html)\n2. [非阻塞算法简介](https://www.ibm.com/developerworks/cn/java/j-jtp04186/)\n3. [SynchronousQueue简介](https://www.cnblogs.com/duanxz/p/3252267.html)\n4. [源码分析-SynchronousQueue](https://blog.csdn.net/u011518120/article/details/53906484)\n","tags":["BlockingQueue"],"categories":["Java"]},{"title":"项目中java创建子进程造成的I/O阻塞问题定位和解决","url":"%2F2019%2F04%2F27%2Fjava-runtime-execute-inputstream-blocking%2F","content":"\n记录一个bug的debug过程，bug起因是`后台调度程序`启动一个异步任务去调用一个docker容器包裹的工具服务（mutation变异测试工具），正常运行的情况下docker容器会正常的退出并自我销毁。而这次的现象是docker容器没有退出而一直处于运行状态。\n\n❤️------------------❤️\n\n<!-- more -->\n\n## 原因分析\n\n### docker下手\n分析`docker`未停止的原因大概率是docker所做的事情没有结束。所以，`docker exec`进入容器，用`jps`查看`Java进程`状态，果然发现进程并没有运行结束。\n\n### 观察java进程\n\n1. `jps`观察现象，有两个java进程在运行，`pid=430`就是我们的主进程，`pid=300`是主进程内新启动的一个子进程。\n```bash\n300 MutationTestMinion\n430 Jps\n```\n2. `jstask [pid]` 查看两个进程的线程栈。 \n**查看主进程的线程栈日志如下:**\n![主进程](http://pic.menduo.xyz/20190501204936.png)\n**查看子进程的线程栈日志如下:**\n![子进程](http://pic.menduo.xyz/20190501212950.png)\n**现象：**\n主线程正在读取inputStream,子线程正在写入outputStream。两个进程均阻塞住，无法继续运行。\n\n### 分析代码\n\n1. 拉代码，本地定位到具体的关键代码如下（比查bug更痛苦的就是查别的的bug了）\n```java\nString[] commands = {\"bash\", \"-c\", commandStr};\nProcess p = Runtime.getRuntime().exec(commands);\noutput = IOUtils.toString(p.getInputStream());\n``` \n\n2. 查看`Process`的文档和各种博客：\n\n**收集的有用的信息：**\n- 创建`Process`方式有两种： ① `ProcessBuilder`; ② `Runtime`.\n- 创建的`Process`没有自己的终端和控制台，他们的`标准I/O（stdin,stdout,stderr）`会被重定向给父进程，为此Process提供了方法`getOutputStream()`,`getInputStream()`,`getErrorStream()`来实现这个功能。\n- **重点：** 由于各平台对于标准I/O 设置了有限制的缓冲区大小。导致写入缓冲区可能会发生阻塞或者死锁的现象！！！原文：\n``` java\n /*\n * The parent process uses these streams to feed input to and get output\n * from the subprocess.  Because some native platforms only provide\n * limited buffer size for standard input and output streams, failure\n * to promptly write the input stream or read the output stream of\n * the subprocess may cause the subprocess to block, or even deadlock.\n */\n```\n\n## Bug详细解释\n\n通过上面的逐步分析，已经可以明显的知道原因是什么了：\n\n`子进程`在执行的过程中会向标准I/O的缓冲区中写入`标准输出`和`错误输出`，而主进程没有对子进程的`错误输出`进行处理，导致子进程发现`错误输出`缓冲区满了的时候自己阻塞住，无法继续运行。而主进程因为子进程无法运行结束，所以`getInputStream()`一直认为还会有数据，会一直等待来自子进程的`标准输出`，所以也阻塞在了`getInputStream()`。 程序中没有任何的超时机制，java进程阻塞住，所以docker也就阻塞住了。\n\n## 解决&引入新的bug \n\n关键点就是 要及时处理子进程的`标准输出`和`错误输出`,因此我们可以启动两个线程分别去处理两个输出，然后主进程等待子进程运行结束就可以了，关键代码如下：\n```java\nExecutorService single = Executors.newCachedThreadPool(); //启动个线程池\nFuture<String> errorOutput = single.submit(() -> IOUtils.toString(p.getErrorStream()));\nFuture<String> inputOutput = single.submit(() -> IOUtils.toString(p.getInputStream()));\nsingle.shutdown(); // 这里一定要主动关闭线程池。\np.waitFor(); //主线程挂起，等子进程结束\noutput = inputOutput.get(); // 获取输出结果\n```\n程序首先启动了一个线程池，添加了两个任务分别去处理标出输出和错误输出。然后关闭线程池，拒绝新的任务加入进来，主进程等待子进程运行结束后，再去获取线程池中的线程中的运行输出结果。\n\n我在写这个代码的时候引入了一个新的bug,就是没有手动关闭线程池,导致我有一段时间怀疑我之前看的文档和bug分析是不是错的，所以又去复现了一波，发现处理任务的子进程已经运行结束了，主进程park在了`ThreadPoolExecutor.getTask()`, 线程池在确认没有任务加入的时候一定要手动关闭`shutdown()`,否则会导致主进程因为有后台线程在运行的缘故，无法运行结束，造成的结果也是docker阻塞住，其实就是线程池在等待处理新的task而进行的自旋阻塞。幸好因为面试看过线程池源码，确认是线程池阻塞在等待任务的问题。所以多看源码还是对自己很有帮助的，有机会再总结一波线程池相关的源码分析。\n![线程池阻塞](http://pic.menduo.xyz/20190502153421.png)\n\n\n## 后记\n\n1. 关于线程池状态的说明\n\n```java\n/*  -1 RUNNING:  Accept new tasks and process queued tasks 可以接受新的任务并处理\n*   0 SHUTDOWN: Don't accept new tasks, but process queued tasks 不再接受新的任务，但是会处理完队列里的所有任务\n*   1 STOP:     Don't accept new tasks, don't process queued tasks, \n*             and interrupt in-progress tasks 不在接受任务，也不处理队列里的任务，同时中断正在处理任务\n*   2 TIDYING:  All tasks have terminated, workerCount is zero,\n*             the thread transitioning to state TIDYING\n*             will run the terminated() hook method 所有任务终止，worker数为0 线程改变状态为TIDYING \n*   3 TERMINATED: terminated() has completed 终止方法运行完成\n*/\n```\n\n\n2. 为什么这里线程池需要手动shutdown，直接看源码发现，线程池会不断的去获取`task`放入`worker`执行的代码是一个for死循环，其中的退出条件:\n   - 线程池状态码 >= SHUTDOWN 并且 （状态 >= STOP || 队列里没任务) 这个看上面的状态码就可以理解了，我们手动调用shutdown的原因就是这个\n   -  从队列里获取一个task,获取成功则返回\n\n```java\nprivate Runnable getTask() {\n        //...略\n        for (;;) {\n            int c = ctl.get(); \n            int rs = runStateOf(c); //获取线程池状态\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n            //...略\n            try {\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n```\n\n\n## 参考资料\n\n1. Java doc\n2. [Process.getInputStream()阻塞问题](https://blog.csdn.net/yuanzihui/article/details/51093375)\n","tags":["开发"],"categories":["Java"]},{"title":"一道笔试题的思考:基本类型和包装类型进行数据比较的问题总结","url":"%2F2019%2F04%2F21%2Fint-with-integer%2F","content":"\n昨天阅文的一道笔试题，让仔细解释一下 `int`和`Integer`各种不同数据比较的问题，我发现自己能说出来的东西挺少的。阿里一面面试官说我了解知识的深度不够的问题，确实让我想了很多，其实我给自己的`特质`定位应该是可以迅速发现问题并解决、可以很快的举一反三，但是很少会因为这个问题去思考到底是底层是因为什么，也就是说`总结反思`的能力太差了，说白了还是修炼不到位，平时太懒了。\n\n所以以后遇到的每个问题都要认真的记录下来。争取秋招拿offer!\n\n<!-- more -->\n\n对于这个问题，首先有个**装箱**和**拆箱**的概念要首先被明确。也就是基本类型和包装类型可以相互转化。\n\n### 什么是装箱和拆箱？\n\n对于每一个基本类型都会有一个对应的包装类型。例如`int`的包装类型就是`Integer`。而拆箱动作就是将包装类型转化为基本类型，装箱动作就是将基本类型变成包装类型。\n\n#### 对应的API,以Integer为例：\n- 基本类型 --> 包装类型 Integer i = Integer.valueOf(int);\n\n```java\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)]; \n        //常量池缓存。[-128,127 or high] 默认127\n        //其中缓存池high大小可通过参数『java.lang.Integer.IntegerCache.high』进行调整,\n        //最大为Integer.MAX_VALUE - 128 - 1 \n    return new Integer(i);\n}\n```\n\n- 包装类型 --> 基本类型 int ii = i.intValue();\n\n``` java\npublic int intValue() {\n    return value;\n}\n```\n**总结：装箱操作就是调用包装类型的valueOf ;拆箱操作就是调用包装类型的xxValue()**\n\n#### Java可以做到自动拆箱和装箱\n\n> 在java中已经实现了自动拆箱和装箱的操作。\n\n> 时机：当任何一个操作中混用了基本类型和装箱类型，装箱类型就会进行拆箱操作。\n\n\n### 总结几个混合使用的要点\n\n#### 一些简单的测试用例进行解释整个 int和Integer进行比较的总结：\n\n- int 和 Integer进行混合比较时，Integer会进行拆箱操作变成基本类型。\n- Integer xx  = 1 这种会调用valueOf自动装箱。\n- Integer进行new操作的对象是放到堆上的。\n- Integer 调用valueOf返回的对象，分两种情况：① -128 <= x <= 127 返回的常量池缓冲区的对象 ② x > 128 会在堆上new一个新的对象 (只考虑默认的情况)\n\n#### 具体的几个测试用例\n```java\n    public static void main(String[] args) {\n        int a0 = 1;\n        int b0 = 128;\n        Integer a1 = 1;\n        Integer b1 = 128;\n        Integer a2 = new Integer(1);\n        Integer a3 = Integer.valueOf(1);\n        Integer b3 = Integer.valueOf(128);\n        Integer a4 = Integer.valueOf(1);\n        Integer b4 = Integer.valueOf(128);\n        System.out.println(a0 == a1); //true 首先a1返回的是常量池中的对象，又因为和int进行比较所以进行拆箱操作\n        System.out.println(b0 == b1); //true 同上，但是会在堆上new一个新的对象然后自动拆箱\n        System.out.println(a1 == a2); //false 首先 a1是缓存在常量池的对象，a2是在堆上new的对象\n        System.out.println(a3 == a2); //false a3返回的是放在常量池中的对象，两个对象不是同一个\n        System.out.println(a3 == a1); //true 返回都是常量池的中的对象，比较地址相等\n        System.out.println(a3 == a4); //true 返回都是常量池进行缓存过的对象，比较地址相等\n        System.out.println(b3 == b4); //false 两个堆上新new对象，具体看valueOf源码，在上面\n        System.out.println(a0 == a4); //true 拆箱比较\n        System.out.println(b0 == b4); //true 拆箱\n        System.out.println(b1 == b4); //false 装箱返回new的堆上对象 和 new的堆上对象\n    }\n```","tags":["基础知识"],"categories":["Java"]},{"title":"FileZip导致的JVM崩溃问题分析","url":"%2F2019%2F03%2F10%2Ffilezip-cause-jvm-crush-md%2F","content":"\n3.10 爬起床查日志，改bug.T_T.\n<!-- more -->\n\n## ZipFile 导致JVM奔溃现象分析\n\n### 现象：\n1. 日志无任何异常产生，但是服务进程已经死掉。定位到日志最后一行线程调用了`OnlineJudgeControler`，因此怀疑是慕码社区的代码（也就是我的锅T_T）导致的崩溃\n2. 查看JVM崩溃日志`hs_err_pid**.log`，发现down机时，线程发出了SIGBUS信号，线程停在了ZipFile对代码包解压上。搜索了一下网上关于这方面的解释。\n\n### 原因\n具体原因就是：我的一个接口会去下载一个压缩包到一个特定的目录，然后在解开这个压缩包（这个文件被映射到了系统内存），但是如果此时另外一个线程也执行这个接口就会将这个压缩包重写（改写了硬盘文件）。导致第一个解压过程出现异常（因此此时会发现自己已经被另外一个线程改变了），从而导致了JVM直接崩溃。\n\n**这里解释一下mmap内存机制：**\n\n我们知道直接对磁盘上的内容会比从内存中读去慢很多，mmap内存文件映射其实就是将磁盘上的一个文件映射到内存中的作用。进程通过对内存的修改来达到对文件的修改，因此mmap系统调用常常用于进程间共享内存方式的系统调用。\n\n**官方给出的关于mmap导致JVM崩溃的解释：**\n\nDisabling mmap Usage (on Solaris or Linux) This release includes a new system property, sun.zip.disableMemoryMapping, which allows the user to disable the mmap usage in Sun's java.util.zip.Zipfile implementation (on Solaris and Linux platforms). Solaris or Linux applications that use java.util.zip.ZipFile may experience a SIGBUS VM crash if the application accidentally overwrites any zip or jar files that are still being used by the same Java runtime. Although this is a programming error of the offending application, this system property provides a solution to avoid the VM crash. With the property set to true (-Dsun.zip.disableMemoryMapping=true, or simply -Dsun.zip.disableMemoryMapping) the Sun JDK/JRE runtime disables the mmap usage and the VM crash that might otherwise occur by overwriting the jar or zip file can be avoided.\n\n\n### 解决方法\n\n1. 官方说明的那样对zip禁用mmap\n> 在启动参数中加入-Dsun.zip.disableMemoryMapping=true \n2. 对代码进行修改，防止多个进程访问同一个文件，可以考虑加锁，或者对该文件进行备份，每个线程访问不同的文件\n\n\n### 参考资料\n\n> 参考资料1 https://blog.csdn.net/zqixiao_09/article/details/51088478\n> 参考资料2 https://my.oschina.net/shipley/blog/979231","tags":["日志"],"categories":["JVM"]},{"title":"headfirst设计模式-工厂和抽象工厂笔记","url":"%2F2018%2F12%2F03%2Fhead-first-1-factory%2F","content":"\n> 设计模式-工厂和抽象工厂。\n> github: [https://github.com/DmuMenDuo/JAVADesignPattern](https://github.com/DmuMenDuo/JAVADesignPattern/tree/master/src/xyz/menduo/factory)\n\n<!-- more -->\n\n## 工厂模式\n\n等到运行时才会知道去实例化哪个，工厂模式也是对设计原则中的将变化与不变化分离的典型应用。\n\n### 简单工厂模式\n\n**什么时候用简单工厂模式？**\n\n发现出现大量的条件判断去创建不同`instance`的对象的时候就可以考虑用工厂将其进行封装了。判断的理由就是这段代码出现了变化，所以要进行封装进行提取。\n\n简单工厂模式UML图：\n![简单工厂模式uml图](http://pic.menduo.xyz/20181130192703.png)\n\n\n### 静态工厂模式\n\n**静态工厂模式：**\n\n> 静态工厂模式只不过是将简单工厂模式的工厂变成了静态类 \n\n**静态工厂的优点和缺点？**\n\n> 优点：工厂无需实例化\n> 缺点：工厂无法通过继承来改变方法的行为。\n\n### 工厂模式\n\n![工厂UML图](http://pic.menduo.xyz/20181202152129.png)\n\n父类提供一个抽象方法，子类负责实现，这个实现的内容就是一个工厂在产生对象的过程。\n![工厂](http://pic.menduo.xyz/20181113154209166559267.png)\n\n\n**工厂模式定义：**\n\n工厂模式是用来封装'对象创建'使用的模式，他通过声明一个抽象父类让子类决定应该去创建什么具体对象。\n![工厂模式-2018111815425544733044.png](http://pic.menduo.xyz/2018111815425544733044.png)\n\n\n**简单工厂和工厂模式的区别？**\n\n工厂模式是创建了一种框架（父类定义，子类实现new对象）。而简单工厂没有。所有工厂模式比简单工厂更加有弹性。\n\n**工厂模式有什么好处？**\n\n封装了变化。代码可以重复利用，方便维护。\n\n\n### 抽象工厂模式\n我理解的`抽象`这个词的含义是，这个工厂类没有具体指明是什么具体的工厂，而是一组工厂，用来实例化一组产品组，或者实例化一个产品的各个部分。\n\n![20181118154255459072470.png](http://pic.menduo.xyz/20181118154255459072470.png)\n\n\n### 对比一下工厂模式和抽象工厂模式\n\n1. 工厂模式采用的继承的方式，父类定义个抽象方法，子类去实现。这个实现的过程就是去创建自己需要的对象。\n2. 抽象工厂是定义一个公共接口，每一个接口都是一个要实例化对象的方法。抽象工厂在使用的时候会被当成属性注入需要实例化的地方。","tags":["设计模式"],"categories":["设计模式"]},{"title":"青海小憩","url":"%2F2018%2F08%2F10%2Fqinghai5day%2F","content":"\n距离开学还有一个月的时间，一次去参加会议的偶然机会，就有了这次的青海五日游。\n刚刚好的季节，刚刚好的行程。吃过了最好吃的羊肉，喝过了最好喝的酸奶，看过了最好看的天。人生也就不过如此吧！\n\n\n\n<!-- more -->\n\n\n\n##### 旅行前的准备\n\n其实要准备的东西也没有什么的，最重要的保命物品就是`防晒霜`!!!。不管男生女生这个真的很重要，我滴妈，我没带被晒得老惨了，褪了一层皮；带一件`外套`和`长裤`，那边早上和晚上还是挺冷的。emmmmm.可以带双`拖鞋`，天空之境还是蛮漂亮的，如果要去盐湖的话可以带双拖鞋准备下水用。还有就是`相机`,那边太漂亮啦，只恨自己拍照技术太渣，手机像素太渣。\n\n##### 第一天：西宁市: 青海省博物馆 -- 东关清真寺 -- 莫家街\n到了西宁一定要去试一下当地的手撕羊肉和老酸奶，实在而且超级好吃，反正我们是安顿好住宿就去找手撕羊肉了。之后去了一下青海省博物馆，它也在西宁市内而且没有门票费，如果想去了解当地文化的话可以去那里转转；因为那边穆斯林比较多，所以清真寺也会比较多，东关清真寺应该当地最大的一座清真寺了，里面还有人讲解穆斯林文化；最后就是晚上去莫家街找吃的，这条小吃街还是蛮有名的，好像正好赶上那边的美食节，所以吃的很满足。\n![西宁市内](http://pic.menduo.xyz/20181113154207578552083.jpg)\n\n##### 第二天：塔尔寺 -- 拉脊山 -- 青海湖二郎剑\n塔尔寺，藏传佛教的圣地。\n<!-- ![塔尔寺](http://pic.menduo.xyz/20181113154207665760536.jpg) -->\n![塔尔寺](http://pic.menduo.xyz/20181113154207693250517.jpg)\n逛过塔尔寺之后就准备去青海湖二郎剑啦，中间穿过了拉脊山，最高海拔4500多米，讲道理还是会有高原反应的，不过司机建议是不要吸氧气，适应适应就好啦。下面的照片就是在拉脊山上拍的。\n![拉脊山](http://pic.menduo.xyz/20181113154207816952435.jpg)\n青海湖二郎剑景区，图1是在船上拍到的，可以看见的阳光。图二叫经幡，当地牧民用来祈求福运隆昌，消灾灭殃。\n![青海湖二郎剑](http://pic.menduo.xyz/20181113154207873353621.jpg)\n之后住宿的地方可以选择黑水镇，不过我们没有订到，所以去了很远的石乃亥，以至于去天空之境的时候多走了一段重复的路。不过路上风景很美所以不会很无聊。\n##### 第三天：石乃亥 -- 天空之境\n本来是有安排看日出的，不过很遗憾的是在石乃亥的两天早上都是阴天还下了小雨，到九点多才晴天。不过还好到天空之境，也就是卡茶盐湖的时候，天气很给面子。\n![天空之境-卡茶盐湖](http://pic.menduo.xyz/20181114154212694423885.jpg)\n其实我们的行程蛮充裕的。以至于在青海湖旁边的草原上玩了一下午。和小伙伴们跳到缺氧。。。。\n![青海湖旁不知名草场](http://pic.menduo.xyz/20181114154212697758897.jpg)\n##### 第四天：回到西宁市\n第四天就是回到西宁市准备开会啦。中间去了原子城学习了一下，抱着学习的目的所以就没拍照片了，然后就是季节有点晚要不然可以看到成片的油菜花海。我们去的时候已经没有了。\n\n\n-- end -- \n\n\n","tags":["青海"],"categories":["旅行"]},{"title":"使用Docker-Java动态的获取Container的log日志","url":"%2F2017%2F12%2F13%2Fget-log-from-docker-container%2F","content":"\ndocker-java 是 JAVA 操作Docker Remote API 的一个工具。最近项目需要读取容器的运行日志出来。记录一下自己遇到的问题。更多其他的问题可以参考他们的测试用例。\n> github地址: [docker-java](https://github.com/docker-java/docker-java) 目前版本 3.0.13\n\n<!-- more -->\n\n### 准备工作\n#### 1. 首先要开启docker的客户端 (我电脑 ubuntu16.04)\n\n```bash\n#查看配置文件位于哪里\nsystemctl show --property=FragmentPath docker \n#编辑配置文件内容，接收所有ip请求\nsudo gedit /lib/systemd/system/docker.service  \nExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://127.0.0.1:8787\n# 这样配置的目的是可以通过http的方式进行远程访问，如果不需要的话可以通过自带的sock方式本地访问\n#重新加载配置文件，重启docker daemon\nsudo systemctl daemon-reload     \nsudo systemctl restart docker \n\n```\n\n#### 2. 建工程 && pom.xml引入依赖\n\n```xml\n<dependency>\n  <groupId>com.github.docker-java</groupId>\n  <artifactId>docker-java</artifactId>\n  <version>3.0.13</version>\n</dependency>\n```\n\n### 获取容器实时运行结果\n\n\n> 通过查看容器日志的方式,\n> 设置一个回调函数，重写onNext(),就可以取到运行的结果了\n\n```java\ndockerClient.logContainerCmd(dockerId).withStdOut(true).withStdErr(true)\n                    .exec(new LogContainerResultCallback(){\n                        @Override\n                        public void onNext(Frame item) {\n                            super.onNext(item);\n                            System.out.println(\"容器运行的结果：\"+item.toString())\n                        }\n                        @Override\n                        public void onComplete() {\n                            super.onComplete();\n                        }\n                    }).awaitCompletion();\n```\n\n> `awaitComletion()`就是让查日志进程阻塞，直到进程调用onComlete()\n> 最好等容器停止后再去读，因为容器在运行中可能还没产生日志，但callback读的时候以为读完了，直接执行onComplete就结束了，因此没有输出。 所以建议查日志前，检查一下容器运行情况，代码如下：之后一直循环判断直到容器停止就可以了\n\n```java\n\t//获取容器的运行状态\n\tdockerClient.inspectContainerCmd(dockerId).\n                exec().getState().getRunning();\n```\n\n\n","tags":["bug解决"],"categories":["docker"]},{"title":"翻译文章:JVM架构简析","url":"%2F2017%2F10%2F10%2Ftrans-jvm-structure%2F","content":"\n\n每个JAVA开发者都知道字节码将会被**JRE**（java运行时环境）所执行，但是许多人不知道的是**JRE**是**java虚拟机**（JVM）分析字节码，解释代码，以及执行它的那部分实现。对于一个开发者来说知道了解JVM的架构是非常重要的，因为它可以让我们更有效地编写代码。在这篇文章，我们将更深入的了解java中的**JVM架构**以及JVM的**不同组成部分**。\n\n> 原文地址：https://dzone.com/articles/jvm-architecture-explained\n\n<!--more-->\n\n----------\n\n## JVM架构简析\n\n\n> 一个JVM不同组成部分的综述，以及和其相关的一些图表\n\n![20181119154259959133032.png](http://pic.menduo.xyz/20181119154259959133032.png)\n\n### 什么是JVM？\n\n一个**虚拟机**是一个物理机的软件实现。java开发的概念是**WORA（一次编写到处运行）**，所以运行在**虚拟机**上。**编译器**编译java文件生成**.class**文件。然后**.class**文件被放入到一个可以加载执行他的虚拟机中。下面是一个JVM 架构的图。\n\n### JVM是如何工作的？\n\n在上述的架构图中，JVM被分成了三个主要的子系统：\n\n1. 类加载子系统。\n2. 运行时数据区域。\n3. 执行引擎。\n\n#### 1. 类加载子系统\n\njava的动态类加载机制在类加载子系统中被处理。由它加载，连接，以及在**运行时**第一次引用类时初始化类文件，而不是在**编译时**。\n\n##### 1.1. 加载\n\n类们将会被这个组件加载。BootStrap 类加载器 ，Extension 类加载器，和Application类加载器将会帮助完成这个过程。\n\n1.  **BootStrap类加载器** - 它的责任是加载那些启动相关路径里的类，不仅仅只是rt.jar。最高的优先权被给于给这个加载器。\n\n2.  **Extension类加载器** - 它的责任是加载那些包含在**jre/lib下的ext**文件夹内的类。\n\n3.  **Application类加载器** - 他的责任是加载**用户定义的classpath下**以及路径涉及的环境变量等等里面的类。\n\n上述的**类加载器**都遵循**双亲委派模型**去加载类文件。\n\n##### 1.2 连接\n\n1.  **验证 **- 字节码验证器将会验证生成的字节码是否正确，如果验证失败那么我们将得到一个验证错误。\n\n2.  **准备** - 为所有静态变量分配内存并且设置初始值。\n\n3.  **解析** - 所有的符号引用将会被替换成方法区的直接引用。 \n\n##### 1.3 初始化\n\n这是类加载的最后时期，这时候所有的静态变量都会被赋予初值，并且执行类中的静态块。\n\n\n#### 2. 运行时数据区\n\n运行时数据区被分成了五个主要部分：\n\n\n- **方法区** - 所有**类相关数据**将会被存储在这里，包括静态变量。每一个JVM只有一个方法区，所以它中的资源是被共享的。\n- **堆** - 所有的**对象**以及他们相关的**实例化变量和数组**被存储在这里。每一个JVM也只有一个堆。因为**方法区**和**堆**是线程间共享的，因此数据的存储**不是线程安全**的。\n- **栈** - 对于每个线程，都将创建一个单独的**运行时栈**。对于每一个**方法调用**，一个被叫做**栈桢**的实体将会在栈内存中被创建。所有的**局部变量**将会在栈空间被创建。栈空间是线程安全的因为它不共享资源。栈桢被分成如下三个子部分：\n    - **局部变量表** - 涉及方法的所有**本地变量**以及和他相关的值被储存在这里。\n    - **操作数栈** - 如果需要执行任何中间操作，**操作数栈**扮演者运行时工作空间的作用去执行这些操作。\n    - **桢数据** - 该方法对应的所有符号都存储在这里。在任何**异常**情况下，捕获块信息将在帧数据中维护。\n- **程序计数器** - 每一个线程都有一个独立的**程序计数器**，来保存**当前指令地址**，一旦指令执行完成就**更新**程序计数器为下一条指令地址。\n- **本地方法栈** - 本地方法栈保存本地方法信息。对于每一个线程，一个独立的本地方法栈将会被创建。\n\n#### 3. 执行引擎\n\n分配到**运行时数据区**的字节码会被执行引擎执行。执行引擎读取字节码并逐步的执行。\n\n-  **解释器** -  解释器可以很快的解释字节码，但是却执行的很慢。解释器的一个缺点就是当一个方法被调用多次后，每次都需要重新被解释。\n-  **实时编译器** - 实时编译器弥补了解释器的不足。执行引擎将在转换字节代码时使用解释器的帮助，但是当它发现重复的代码时，它使用的是JIT编译器，它编译整个字节码并将其更改为本地代码。这种本地方法将会直接被使用在重复的方法调用上，来提升系统的性能。\n    - **中间代码生成器** - 生成中间代码。\n    - **代码优化器** - 负责优化上面生成的中间代码。\n    - **目标代码生成器** - 负责生成机器代码或本地代码\n    - **分析器** - 一个特殊的组件，负责找热点，例如，是否一个方法被多次调用等等。\n\n- **垃圾收集器** - 收集以及移除未被引用的对象。垃圾回收将会被这个\"**System.gc()**\"调用触发,但是这个执行时不确定的。JVM的垃圾收集器收集被创建的对象。\n\n**Java Native Interface (JNI)**: **JNI**将与**本地方法库**交互，并提供执行引擎所需的本地库。\n**本地方法库**:它是执行引擎所需的本地库的集合。\n","tags":["JVM"],"categories":["java"]},{"title":"2018年专业书单","url":"%2F2017%2F09%2F12%2F2018booklist%2F","content":"\n软狗不是每天都在搬砖的！！！ 我爱学习~\n\n今年要补些本科落下的基础知识了。面试时候遇到的JAVA相关的知识。毕设要用到Docker和机器学习算法也学一下。 软狗要全栈（除了前端\n<!-- more -->\n\n####  JAVA并发编程艺术\n\n> java并发的一些基础知识，以及J.U.C的一些常用类。PS：新买的，在火车上看了1/3就丢了，现在只能啃电子书。很真实。。。mmp\n\n\n#### JAVA8函数式编程\n\n> 强烈推荐，如果想快速上手Java8,学会Lamda，这是一本好书，很薄，代码也可以在github下载到\n\n#### Docker技术入门与实战\n\n> 一本关于docker的工具书。\n\n\n####  Effecttive Java 英文版（第三版）\n\n> 第三版相对于第二版多了很多JAVA8的内容，由于还没有中文版，所以只能读英文的了\n\n#### 机器学习\n\n> 读论文的时候发现很多人在用机器学习的算法，周大牛的机器学习是必备的吧 \n\n\n\n\n","tags":["读书"],"categories":["读书"]},{"title":"2018年娱乐书单","url":"%2F2017%2F09%2F12%2F2018booklist2%2F","content":"\n经常被说文盲，多读书是好呀，和别人聊天可以找找话题~\n\n\n\n<!-- more -->\n\n1. 未来简史 `看不懂看不懂...`\n2. 白金数据 `算不算马上就成为现实的故事？或者已经是现实了？`\n3. 从0到1:开启商业与未来的秘密 `我觉得从投资人的角度对于一个好创业公司的讲解很透彻，应该如何看待创业公司，以及创业公司应该如何生存法则。`\n4. 这世界既残酷也温柔 `我觉得很无聊的一本书,没什么值得借鉴的营养故事,装逼史:北大-->留学-->买比特币-->财务自由-->持续创业。不过抓住机会的能力还是要学习的`\n5. 摆渡人 `超级治愈的一本书`\n6. 摆渡人2 `感觉没有上一部写的好，对于苏珊珊的结局，我不喜欢作者这样处理她，不剧透，23333`\n7. 一只特立独行的猪 `这是一本充斥着个人观点的书，对待任何的事情都要有自己的态度，要会为自己的观点坚持，这就是王小波吧。一个幽默，有个性的老人儿`\n8. 梦幻花 `关于一株不存在的致幻花的故事，真的很佩服东野圭吾，总可以在恰到好处的时候将所有的片段结成一个完整的故事。`\n9. 虚无的十字架 `我认为是一本十分矛盾的书，每个人都是在弥补自己曾经的过错去做另一件更错的事。书中的很多思想关于判刑对一个人以及其周围的影响，冲击着日本目前的法律制度。可能是因为之前的江歌案吧，日本的法律真的可以宽恕罪行。`\n10. 刺杀骑士团团长 `一开始以为书中的我产生了人格分裂，那个骑士团长以及斯巴鲁男人是他的两重人格，后来......书一直围绕着那幅可以救赎的刺杀骑士团长的画展开，不过结局矛盾的人全部得到了自己想要的答案真好啊。`\n11. 刺 `一本关于校园暴力，职场暴力以及网络暴力的书，文中想表达的思想全在字面上，很容易读懂。佩服作者敢于发声。`\n12. 高情商聊天术`记不得讲什么了，反正现在看感觉什么都没说`\n13. 毕业 `东野圭吾的小说总是很吸引人...其实不打算看的，但还是一口气看完了。可能脑子比较笨，经常猜不到结局才喜欢看的吧`\n14. 秘密 `又一本东野圭吾的书，在读到一半的时候猜到了我最不喜欢的结局！！！`4\n15. 龙族(1-4） `江南的小说还是很好看的！`\n16. 人月神话 `软件需求课的作业`","tags":["小说"],"categories":["读书"]},{"title":"2017娱乐书单","url":"%2F2017%2F01%2F05%2F2017booklist2%2F","content":"\n2017年小说书单\n\n<!-- more -->\n\n1. 不正常人类症候群 - 张寒寺\n2. 浮躁 - 贾平凹\n3. 解忧杂货店 - 东野圭吾\n4. 三体（全集） - 刘慈欣\n5. 湖畔 - 东野圭吾\n6. 无人生还 - 阿加莎·克里斯蒂\n7. 2015年度300问：心理 - 知乎\n8. 嫌疑人X的献身 - 东野圭吾\n9. 神探伽利略 - 东野圭吾\n10. 腾讯传1998-2016：中国互联网公司进化史\n11. 恶意 - 东野圭吾\n12. 时间的形状：相对论史话 - 汪洁\n13. 分歧者 - 维罗妮卡·罗斯\n14. 黑石之墓 - 克莱尔·麦克福尔\n15. 白夜行 - 东野圭吾\n16. 十一种孤独 - 理查德·耶茨\n17.  地狱变 - 蔡骏\n18. 我有故事，你有酒吗？ - 关东野客\n19. 芳华 - 严歌苓\n20. 天才在左，疯子在右\n21. 假面饭店 - 东野圭吾\n22. 放学后 - 东野圭吾\n23. 流星之绊 - 东野圭吾","tags":["小说"],"categories":["读书"]},{"title":"2017专业书单","url":"%2F2017%2F01%2F05%2F2017booklist%2F","content":"\n这里要放2017年读过的书单~\n\n<!-- more -->\n\n####    JAVA核心技术 卷I（卷2没看）\n\n> 我的入门java的第一本书\n\n####    剑指offer\n\n> 面试必备呀，刷了好几遍，打算下次面试之前在刷一次\n\n####    深入理解Java虚拟机\n\n > 还是面试必备啊，面试官特别喜欢问这里面的JVM知识，不过，确实是了解JVM最经典的书了。\n\n\n####    Effecttive Java 中文版（第二版）\n\n> 讲如何规范的写Java，里面很多前人的经验值得借鉴，感觉是一本可以读很多遍，每次读都能发现新大陆的书\n\n####    大型分布式网站架构 设计与实践 - 陈康贤\n\n > 讲了分布式业界常见的解决方案，算是一本不错的科普书。\n","tags":["读书"],"categories":["读书"]}]